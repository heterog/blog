<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Heaven Is</title><link>https://error.iorw.io/</link><description>Recent content on Heaven Is</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>unlicense yet.</copyright><lastBuildDate>Sun, 18 Jun 2023 14:46:01 +0800</lastBuildDate><atom:link href="https://error.iorw.io/" rel="self" type="application/rss+xml"/><item><title>混乱中立与 Emacs</title><link>https://error.iorw.io/2023/06-18-weird-emacs-workflow/</link><pubDate>Sun, 18 Jun 2023 14:46:01 +0800</pubDate><guid>https://error.iorw.io/2023/06-18-weird-emacs-workflow/</guid><description>
&lt;figure>
&lt;img src="https://cdn.pixabay.com/photo/2018/09/22/11/21/cat-3695040_1280.jpg" alt="https://cdn.pixabay.com/photo/2018/09/22/11/21/cat-3695040_1280.jpg" title="https://cdn.pixabay.com/photo/2018/09/22/11/21/cat-3695040_1280.jpg" />&lt;figcaption>
Meow! &lt;a href="https://pixabay.com/photos/cat-paw-keyboard-playful-nasty-3695040">Lemonsandtea&lt;/a>
&lt;/figcaption>
&lt;/figure>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
Why Emacs
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
人类关于 Emacs、Vim 甚至是 VSCode 的争议从未休止，毕竟工具往往跟效率关系密切。对我而言，起初只是想试一试传闻中的 Emacs，看它到底有几分威力，在折腾过如&lt;a href="https://github.com/redguardtoo/emacs.d">陈斌&lt;/a>大佬、&lt;a href="https://github.com/doomemacs/doomemacs">Doom Emacs&lt;/a> 等等配置之后，逐渐开始有点“上头”，开始将日常工作流都迁移到 Emacs 上去。&lt;/p>
&lt;p>
对我来说，Emacs 有这么几个有意思的点：&lt;/p>
&lt;ol>
&lt;li>几乎所有的 buffer、函数、变量等等都是共享的，这让 hack 变得轻松&lt;/li>
&lt;li>Emacs Lisp 有着很不错的表达能力，配合各种文本函数，很轻易地可以写出自己想要的功能&lt;/li>
&lt;li>为了让你能更舒服的 hacking，甚至提供了如 &lt;code>advice-add&lt;/code> 这样的 hijack 功能&lt;/li>
&lt;/ol>
&lt;p>在我看来，Emacs 几乎就是为了让你折腾它而诞生的，打开 Emacs 总会不自觉地开启 &lt;code>.emacs.d&lt;/code> 文件夹（笑），毕竟，当你用的不爽的时候，Emacs 真的允许你去修改。&lt;/p>
&lt;p>
当然，过度的灵活性也是 Emacs 的最大缺点－它违背了 UNIX 哲学：&lt;/p>
&lt;blockquote>
&lt;p>Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new &amp;#34;features&amp;#34;.&lt;/p>
&lt;/blockquote>
&lt;p>
Emacs 作为文本编辑器是不够“纯粹”的，但我个人认为，模块化设计跟效率有着天然的冲突，选择 Emacs 就需要接收模块化不够的问题。就像大家偏好使用 IDE 一样，效率的来源往往就是多个小模块的拼合。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-2" class="outline-2">
&lt;h2 id="headline-2">
help-with-tutorial
&lt;/h2>
&lt;div id="outline-text-headline-2" class="outline-text-2">
&lt;p>
实际上 Emacs 你只需要掌握 &lt;code>M-x&lt;/code> 这么一个快捷键就可以了（认真脸），几乎所有的快捷键都是在执行某个 &lt;code>(interactive)&lt;/code> 命令。比如 &lt;code>C-n&lt;/code> 就是 &lt;code>next-line&lt;/code> ， &lt;code>C-s&lt;/code> 就是 &lt;code>isearch-forward&lt;/code> ，如此。&lt;/p>
&lt;p>
我自己对 Vim 实际上不是很熟，连 &lt;code>ciw&lt;/code> 这种这么好用的命令我都是学 Emacs 的时候发现的，因此选择了走一遍 &lt;code>help-with-tutorial&lt;/code> ；如果你比较熟悉 Vim 的话可以直接使用 Doom Emacs 配置来快速入门。&lt;/p>
&lt;p>
当然，还有必不可少的 Emacs Lisp，这个语言可能对习惯类 C 语言的人来说会很不适应，我感觉是跟函数式类的语言更为接近（虽然多数时候都是按过程式的思维在写 hhhh）。比如：&lt;/p>
&lt;ol>
&lt;li>没有 &lt;code>return&lt;/code> 这样的东东，函数的返回值就是最后 eval 的表达式的值&lt;/li>
&lt;li>最基础的数组和 dict 之类的数据结构表达偏向函数式（例如 &lt;code>car/cdr&lt;/code> 这样的函数）&lt;/li>
&lt;li>括号太多（雾）&lt;/li>
&lt;li>Many, many more&lt;/li>
&lt;/ol>
&lt;p>我的做法是照葫芦画瓢，因为我自身学过一定的 Haskell 这类函数式语言，上手起来没有太多问题。如果觉得 hack 起来有点困难的话，可以参考 &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html">Emacs Lisp 手册&lt;/a>来学习一下，或者别忘了还有 ChatGPT 可以利用。&lt;/p>
&lt;p>
P.S. 可能 Emacs 的 Common Lisp 扩展会让敲代码的体验好一些，无责任推荐（。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-2">
&lt;h2 id="headline-3">
Prelude|Postlude
&lt;/h2>
&lt;div id="outline-text-headline-3" class="outline-text-2">
&lt;p>
在尝试了很多配置之后，都感觉不是很“贴合”自己，尤其是大家似乎都很喜欢 Evil，但我自己更偏爱原生的键位，因为它泛用性比较强，在 &lt;code>bash/zsh&lt;/code> 这类终端下默认就可以使用。因此敲定了 &lt;a href="https://github.com/hartlottery/postlude">Prelude&lt;/a> 作为框架，在此基础上修改。&lt;/p>
&lt;p>
我自己的一些“所谓的”哲学理念（可能有点 bullsht）：&lt;/p>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Modalka
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;p>
为了小拇指的健康，避免因 Control 键按太多而承受不住（雾），一个 modal editing 还是相当有必要的。所谓 modal editing，其实就是给“编辑”这个操作分模式，像 Vim 有 Normal 和 Insert。&lt;/p>
&lt;p>
选择 &lt;a href="https://github.com/mrkkrp/modalka">Modalka&lt;/a> 的原因也很简单，因为它侵入性没有像 Evil 或者 god-mode 那样强，留有了更多的自定义空间。基本仿照着作者本人的配置，映射的基本是 Emacs 的原生键位，但是将常用的 &lt;code>x&lt;/code> 和 &lt;code>c&lt;/code> 键映射为了像 god-mode 那样的 &lt;code>C-x&lt;/code> 前缀调用。&lt;/p>
&lt;p>
因为我自己 LWin 键用的并不多，所以直接将它映射为 &lt;code>&amp;lt;menu&amp;gt;&lt;/code> 键并用来切换 modalka-mode，同时映射 &lt;code>&amp;lt;insert&amp;gt;&lt;/code> 作为 fallback 按键，这样就能通过左手手掌按压来快速切换了。&lt;/p>
&lt;p>
P.S. 不过其实发现自己好像 modal 模式用的不是很频繁，Control 键按的依然“欢快”。可能确实习惯了统一快捷键的方式（？），不过为了小拇指，还是多切切习惯习惯好了。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Workspace
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;p>
工作区则相当接近 i3 这样的配置，不过因为主力系统是 Windows（不要问为什么，我也很想换，但是万恶阿里郎），因此没办法利用 Win 键切换，所以还是用的快件键切换。&lt;/p>
&lt;p>
使用了 Emacs 默认的 &lt;code>tab-bar-mode&lt;/code> 来管理工作区，通过 &lt;code>C-m 1&lt;/code> 这样的快捷键切换。而窗口则使用 &lt;code>winum&lt;/code> 插件配合 &lt;code>M-1&lt;/code> 这样的快捷键快速切换。&lt;/p>
&lt;p>
这么选择主要是感觉日常中切换工作区的频率，相对与切换窗口来说要少一点（虽说如此，我还是很想像 i3 那样的全都要）。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Region
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;p>
日常改代码的时候，最重要的其实就是 region 的操控，如 Vim 经常被使用的 &lt;code>cw&lt;/code> 命令。因此选定了使用 &lt;a href="https://github.com/magnars/expand-region.el">expand-region.el&lt;/a> 来快速选择区域，这部分借鉴了 &lt;a href="https://github.com/meow-edit/meow">Meow&lt;/a> 的设计哲学，先选定区域，再决定动作。当然也从 Meow 那“抄”来了 &lt;code>meow-inner-of-thing&lt;/code> 作为备选。&lt;/p>
&lt;blockquote>
&lt;p>Vim 的逻辑是，我想进行一个替换的操作，作用在一个单词上；&lt;/p>
&lt;p>
Meow 的逻辑则是，我选定了一个单词，对它进行替换的操作；&lt;/p>
&lt;p>
这两种逻辑没有对错，只有针对自己而言是否习惯，我就更偏向于 Meow 的逻辑。&lt;/p>
&lt;/blockquote>
&lt;p>
当然也缝合了 &lt;a href="https://github.com/oantolin/embark">Embark&lt;/a> 来进行操作，但是实际上目前用的并不多，只是搜索符号的时候代替 Vim 的 &lt;code>*/#&lt;/code> 这样的命令。在考虑是否要咔嚓掉 hhhh。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Jump
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;p>
大家好像都很喜欢用 &lt;a href="https://github.com/abo-abo/avy">avy&lt;/a> 来跳转，经过一些小代码浏览的经验，目前我习惯的跳转方式有：&lt;/p>
&lt;ul>
&lt;li>&lt;code>C-;&lt;/code> 跳转到同一行（或者上下两行）的 word 上&lt;/li>
&lt;li>&lt;code>C-&amp;#39;&lt;/code> 任意单词跳转&lt;/li>
&lt;li>&lt;code>C-u X C-n/p&lt;/code> 配合相对行号快速跳转（其实目前这个用的更多，可能是目前对“行”的操作更多）&lt;/li>
&lt;li>&lt;code>C-j d/r&lt;/code> 跳转 + 转到定义或引用，来自 &lt;a href="https://github.com/MaskRay/Config">MaskRay&lt;/a> 大佬的配置&lt;/li>
&lt;/ul>
&lt;p>除此之外也配置了很多其他的跳转方式，但是感觉都不怎么用的样子，主要是我目前还没有完全想好真正高效的定位方式，是 avy 这样更快，亦或是 Emacs 本身的操作就足够了，还是“组合拳”更为适应？&lt;/p>
&lt;p>
现在而言，我尽量遵循 &lt;strong>Jump more, move less&lt;/strong> 的原则，尽量地使用跳转代替 &lt;code>C-f&lt;/code> 等操作，当然在正常编辑中一些小错误的修正还是离不开 &lt;code>C-f&lt;/code> 等。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
&lt;span class="todo">TODO&lt;/span>
Next
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;p>
目前比较纠结要不要把 Meow 替换掉 Modalka，因为它的设计思想确实比较对我，但是又感觉实际上我只是喜欢它的选择模式，有了 &lt;code>expand-region.el&lt;/code> 之后似乎也不那么必需了。我也把 Vim 的 &lt;code>c&lt;/code> 键挪到了 Modalka 上，这样操作区域就更简单了。&lt;/p>
&lt;p>
还有需要酌定的就是所谓的 Ergo，即人体工程学，之前尝试了一下 &lt;a href="https://github.com/jyp/boon">Boon&lt;/a> 发现好像没有必要为了省一点的手指挪动距离而放弃养成的习惯。&lt;/p>
&lt;p>
P.S. 走了一遍 Boon 的 Tutor 才明白，原来手指尽量不移动 + 左右按键分配均衡，就叫做人体工程学键位了。。感觉可以试试 Dvorak/Colemark/Workman 了的说。&lt;/p>
&lt;p>
另外 IDE 常用的向前向后跳转还暂时没有去弄，因为像 &lt;code>better-jumper&lt;/code> 这样的插件都需要自己手动 mark 跳跃点才行，想想还是有一定工作量的。依然还在磨合期（。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-9" class="outline-2">
&lt;h2 id="headline-9">
Devil
&lt;/h2>
&lt;div id="outline-text-headline-9" class="outline-text-2">
&lt;p>
来自 &lt;a href="http://web.archive.org/web/20180602132306/https://plus.google.com/+LinusTorvalds/posts/iySKQGtkmtb">Linus Torvalds&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>So for the other three people out there using &amp;#34;uEmacs/PK&amp;#34; (not to be confused with real emacs, which is the tool of the devil), you can now get a shiny new version of the same old cruddy editor, but now it actually edits UTF8.&lt;/p>
&lt;/blockquote>
&lt;p>
我尝试编译了一份 &lt;a href="https://github.com/torvalds/uemacs">torvalds/uemacs&lt;/a> 玩玩，发现它真的很纯粹（纯粹到按键绑定全都是硬编码在 C 文件里的），而且贯彻着上述“只做一件事”的 UNIX 哲学。也难怪 Linus 会如此评价 Emacs（。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-10" class="outline-2">
&lt;h2 id="headline-10">
混乱中立
&lt;/h2>
&lt;div id="outline-text-headline-10" class="outline-text-2">
&lt;p>
配置久了之后就有一点感受是，当能完全自定义自己的 workflow 时，我发现选择突然太多了，自己似乎无法定夺到底哪种才是更好的，导致自己的配置存在各种“混乱”，很多功能相互重叠，甚至是用不上但感觉又能提升效率。&lt;/p>
&lt;p>
也就是有了一点所谓的 Premature Optimization 的感觉，明明应该是提升效率的，可是最后却被束缚了。思来想去还是觉得，方法是拿来解决问题的，还是回归我遇到的问题本身，再进行客制化吧。&lt;/p>
&lt;p>
可能是 Emacs 天然独有的混乱中立，它可以是为你提升效率的善良天使，也可以是给你捣乱让你反而被束缚住的邪恶魔鬼。&lt;/p>
&lt;p>
给自己的谨记： &lt;strong>工具始终是拿来解决问题，而非折磨自己的&lt;/strong> 。&lt;/p>
&lt;p>
&lt;em>May the Emacs be with you.&lt;/em>&lt;/p>
&lt;/div>
&lt;/div></description></item><item><title>浅入 x86 内存序</title><link>https://error.iorw.io/2022/12-17-memory-order-in-x86/</link><pubDate>Sat, 17 Dec 2022 17:10:42 +0800</pubDate><guid>https://error.iorw.io/2022/12-17-memory-order-in-x86/</guid><description>&lt;pre tabindex="0">&lt;code class="language-log" data-lang="log">[WARN] Using deprecated method `memory-order&amp;#39;, it might be removed in the future.
&lt;/code>&lt;/pre>&lt;h2 id="内存序memory-order">内存序（Memory Order）&lt;/h2>
&lt;p>在 x86 中，内存屏障通常是不需要的，因为 x86 是比较严格的 TSO（不完全，因为始终没有“官宣”，但是按照定义来说比较接近，而且不同的厂商如 AMD/Intel 之间的实现也存在略微差别）。&lt;/p>
&lt;p>百度找到了一份 &lt;a href="https://www.cis.upenn.edu/~devietti/classes/cis601-spring2016/sc_tso.pdf">sc_tso.pdf&lt;/a> 讲述了 TSO 的一些特点，其中包括程序顺序（program order）与内存序（memory order）之间的关系：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Whether they are to the same or different addresses (i.e., a=b or a≠b).If L(a) &amp;lt;p L(b) ⇒ L(a) &amp;lt;m L(b) /* Load→Load */If L(a) &amp;lt;p S(b) ⇒ L(a) &amp;lt;m S(b) /* Load→Store */If S(a) &amp;lt;p S(b) ⇒ S(a) &amp;lt;m S(b) /* Store→Store */&lt;del>If S(a) &amp;lt;p L(b) ⇒ S(a) &amp;lt;m L(b)&lt;/del> /* Store→Load */: Enable FIFO write buffer&lt;/li>
&lt;li>When to the same address, every load gets its value from the last store before it.
If S(a) &amp;lt;p L(a) ⇒ S(a) &amp;lt;m L(a) /* Store→Load */&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>其中 &lt;code>&amp;lt;p&lt;/code> 表示的是程序顺序下的先后关系，而 &lt;code>&amp;lt;m&lt;/code> 则是内存顺序下的先后关系。&lt;strong>注意这里不考虑编译器进行过的指令重排，这里的程序顺序也是编译完后的汇编顺序&lt;/strong>。&lt;/p>
&lt;p>内存序其实不一定要完全写回到内存才算，只要其他 CPU 能看到最终更改就行了（globally visible），例如最常见的 Store-Load，假如 Store(a, 100) 执行完后，那么其他任意的核心在执行 Load(a) 时结果都必须保证为 100；但是这不一定意味着内存中的 a 就一定是 100，有可能它还只是在 L3 Cache 中。&lt;/p>
&lt;p>上面的引用处我还是稍微修改了一点，为了方便阅读；可以看到，对于所有的 Load/Store，三种 Load-Load、Load-Store、Store-Store 都是 SC 的，即内存序就是程序序。但是之所以我们说 TSO 要弱于 SC，是因为对于 Store-Load 这样的操作并没有这么严格，Store-Load 只有在当读写同一个地址（同一片内存时）才是成立的；读写不同内存时 Store-Load 下程序序是不能等价于内存序的。&lt;/p>
&lt;p>能作证这一点的还有 &lt;a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">Intel SDM&lt;/a> Volume 3 8.2.2 部分，这里也摘录了一下：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Reads are not reordered with other reads.&lt;/li>
&lt;li>Writes are not reordered with older reads.&lt;/li>
&lt;li>Writes to memory are not reordered with other writes, with the following exceptions:
&lt;ul>
&lt;li>streaming stores (writes) executed with the non-temporal move instructions (MOVNTI, MOVNTQ, MOVNTDQ, MOVNTPS, and MOVNTPD); and&lt;/li>
&lt;li>string operations (see Section 8.2.4.1).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>No write to memory may be reordered with an execution of the CLFLUSH instruction; a write may be reordered with an execution of the CLFLUSHOPT instruction that flushes a cache line other than the one being written.1 Executions of the CLFLUSH instruction are not reordered with each other. Executions of CLFLUSHOPT that access different cache lines may be reordered with each other. An execution of CLFLUSHOPT may be reordered with an execution of CLFLUSH that accesses a different cache line.&lt;/li>
&lt;li>Reads may be reordered with older writes to different locations but not with older writes to the same location.&lt;/li>
&lt;li>Reads or writes cannot be reordered with I/O instructions, locked instructions, or serializing instructions.&lt;/li>
&lt;li>Reads cannot pass earlier LFENCE and MFENCE instructions.&lt;/li>
&lt;li>Writes and executions of CLFLUSH and CLFLUSHOPT cannot pass earlier LFENCE, SFENCE, and MFENCE instructions.&lt;/li>
&lt;li>LFENCE instructions cannot pass earlier reads.&lt;/li>
&lt;li>SFENCE instructions cannot pass earlier writes or executions of CLFLUSH and CLFLUSHOPT.&lt;/li>
&lt;li>MFENCE instructions cannot pass earlier reads, writes, or executions of CLFLUSH and CLFLUSHOPT.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>其中比较重要的就是上面的第 1、2、3、5 点。翻译下来就是：&lt;/p>
&lt;ul>
&lt;li>1. Load-Load 下内存序等于程序序（不会被重排）&lt;/li>
&lt;li>2. Load-Store 下内存序等于程序序，注意这里写的是 older reads，也就是说当前 Store 指令（&lt;code>MOV&lt;/code> 等）之前的 Load 指令都不会被重新排序&lt;/li>
&lt;li>3. Store-Store 下内存序等于程序序，例外情况是 non-temporal 和 rep mov 之类的指令（后面会提到，在写一般代码时不会太接触到）&lt;/li>
&lt;li>5. Store-Load 下只有当读写的都是同样的地址时内存序才等于程序序，否则对于不同的地址的读写依然会存在重排&lt;/li>
&lt;/ul>
&lt;p>到这里应该大概就了解了为何说 x86 架构普遍都是 TSO，以及为何 TSO 要弱于 SC。&lt;/p>
&lt;h2 id="多核心">多核心&lt;/h2>
&lt;p>&lt;strong>注意&lt;/strong>上述例子都只在单核心中生效，包括 TSO 这些（写这篇文章的时候好像没考虑到单/多核心问题，可能要回炉重造了 FIXME）。对于多核心系统（multiple-processor），SDM Volume 3 8.2.2 同样也定义了：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Individual processors use the same ordering principles as in a single-processor system.&lt;/li>
&lt;li>Writes by a single processor are observed in the same order by all processors.&lt;/li>
&lt;li>Writes from an individual processor are NOT ordered with respect to the writes from other processors.&lt;/li>
&lt;li>Memory ordering obeys causality (memory ordering respects transitive visibility).&lt;/li>
&lt;li>Any two stores are seen in a consistent order by processors other than those performing the stores&lt;/li>
&lt;li>Locked instructions have a total order.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>重点就是，在多核心的情况下，单核心的写入顺序可以保持不变，但是很可能会穿插进其他核心的写操作。SDM 上附带了一个很好的例子来解释这一行为，考虑三个核心都在同时写入数据：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; Writes from individual processors:
Processor#1 Processor#2 Processor#3
Write A.1 Write A.2 Write A.3
Write B.1 Write B.2 Write B.3
Write C.1 Write C.2 Write C.3
&amp;gt; Actual writes (one of the example) in memory:
Write A.1
Write B.1
Write A.2
Write A.3
Write C.1
Write B.2
Write C.2
Write B.3
Write C.3
&lt;/code>&lt;/pre>&lt;p>P.S. 第四点的“因果律”可能一开始让人觉得有点摸不着头脑，可以参考 &lt;a href="https://stackoverflow.com/a/27374794">Stack Overflow&lt;/a> 的例子来了解，实际上就是保证如果单个变量写入且能被正确观测到，那么前面所有的变量写入都应该可以被观测到。个人理解 x86 在多核心的内存序上相对比较“难预测”，内存序依赖于观测到的值，也就是只有在“看”到了实际的值之后，才能知道哪些变量被正确地写入了。&lt;/p>
&lt;h2 id="一个栗子">一个栗子&lt;/h2>
&lt;p>一个我觉得很有“意思”的例子，来源一个知乎文章，介绍&lt;a href="https://zhuanlan.zhihu.com/p/454564295">内存屏障&lt;/a>所用的，原文代码有点乱，这里重新格式化并稍微精简了一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define _GNU_SOURCE
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sched.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;assert.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">volatile&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="n">pthread_barrier_t&lt;/span> &lt;span class="n">barrier_start&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="n">pthread_barrier_t&lt;/span> &lt;span class="n">barrier_end&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">thread1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pthread_barrier_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">barrier_start&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// run1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pthread_barrier_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">barrier_end&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">thread2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pthread_barrier_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">barrier_start&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// run2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">r2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pthread_barrier_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">barrier_end&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pthread_barrier_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">barrier_start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pthread_barrier_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">barrier_end&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pthread_t&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pthread_t&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cpu_set_t&lt;/span> &lt;span class="n">cs&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CPU_ZERO&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CPU_SET&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pthread_setaffinity_np&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CPU_ZERO&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CPU_SET&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pthread_setaffinity_np&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// start()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">r2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pthread_barrier_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">barrier_start&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pthread_barrier_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">barrier_end&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// end()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">r2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// gcc xxx.c -O2 -pthread &amp;amp;&amp;amp; ./a.out
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据原作者阐述，这段程序必定会产生 &lt;code>end()&lt;/code> 处引发的断言错误。那么我们来对着上面的多核心下的内存模型稍微解释一下吧，根据上面的定义，线程 t1 和线程 t2 同时写入变量 &lt;code>x&lt;/code> 与 &lt;code>y&lt;/code>，那么真实的写入顺序有可能是先写 &lt;code>x&lt;/code> 或是先写 &lt;code>y&lt;/code>；不过重点还是“读”的顺序，按照前文关于 Store-Load 序的解释，&lt;code>r1&lt;/code> 和 &lt;code>r2&lt;/code> &lt;strong>不一定&lt;/strong>会读到写入的值（因为不是同一个核心)，x86 内存模型只保证假设真实内存写入顺序为 &lt;code>x = 1; y = 1&lt;/code>，那么如果 &lt;code>r1&lt;/code> 读到 &lt;code>y == 1&lt;/code>，则 &lt;code>r2&lt;/code> 必定也能读到 &lt;code>x == 1&lt;/code>。&lt;/p>
&lt;p>另外按照 SDM 官方的说法（位于 Volume 3 8.2.3.4），&lt;/p>
&lt;blockquote>
&lt;p>At each processor, the load and the store are to different locations and hence may be reordered. Any interleaving of the operations is thus allowed.One such interleaving has the two loads occurring before the two stores. This would result in each load returning value 0.&lt;/p>
&lt;/blockquote>
&lt;p>也就是说对于一个核心而言，只有在&lt;strong>该核心&lt;/strong>上读写同一地址才是顺序的；否则就算多核心都读写同一地址，中间都有可能发生乱序。这两种解释都是行得通的。&lt;/p>
&lt;p>解决方法可以是下面所述的内存屏障，即在写入 &lt;code>x&lt;/code> 或 &lt;code>y&lt;/code> 后引入内存屏障，保证下一条读指令执行前完成写入，即：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// t1/run1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">__asm__&lt;/span> &lt;span class="nf">__volatile__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;mfence&amp;#34;&lt;/span> &lt;span class="o">:::&lt;/span> &lt;span class="s">&amp;#34;memory&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// t2/run2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">__asm__&lt;/span> &lt;span class="nf">__volatile__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;mfence&amp;#34;&lt;/span> &lt;span class="o">:::&lt;/span> &lt;span class="s">&amp;#34;memory&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样一来，所有可能的路径都不再会产生 &lt;code>r1&lt;/code> 和 &lt;code>r2&lt;/code> 同时为零的情况了：&lt;/p>
&lt;ol>
&lt;li>t1 执行到 &lt;code>x = 1&lt;/code>，t2 执行到 &lt;code>mfence&lt;/code>，那么 t1 必然能保证 &lt;code>r1 = y = 1&lt;/code>，因为 t2 使用了 &lt;code>mfence&lt;/code> 强制 CPU 按照 &lt;code>x = 1; r2 = x&lt;/code> 的顺序执行（如果没有 &lt;code>mfence&lt;/code> 就可能会出现 &lt;code>r2 = x; r1 = y; x = 1; y = 1&lt;/code> 的内存读写顺序出现）&lt;/li>
&lt;li>t1 执行到 &lt;code>mfence&lt;/code>，t2 执行到 &lt;code>y = 1&lt;/code>，同样，t2 必然能保证 &lt;code>r2 = x = 1&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>注意 &lt;code>x&lt;/code> 与 &lt;code>y&lt;/code> 是否能够被观测到与指令乱序没有太大关系，内存屏障只保证读写的顺序，但是不保证读写的值是否有效，后者是由 atomic 负责保证的，只是恰巧 x86 下绝大多数读写操作都是原子的，一定要区分好两者的关系 orz。&lt;/p>
&lt;p>另一个粗暴的方法就是所有 mov 操作都带上 lock prefix，保证 total order。&lt;/p>
&lt;p>总而言之，多核心下 x86 内存序能保证的只有写入的顺序，以及“因果律”读到的结果；但是无法保证多核心下读和写的顺序，要保证这种顺序需要依靠内存屏障或是总线锁。&lt;/p>
&lt;h2 id="内存屏障memory-fence">内存屏障（Memory Fence）&lt;/h2>
&lt;p>前文列出的 SDM 卷 3 8.2.2 节里，用了好几个点叙述 &lt;code>xFENCE&lt;/code> 指令，包括 &lt;code>LFENCE&lt;/code>、&lt;code>SFENCE&lt;/code> 和 &lt;code>MFENCE&lt;/code>。&lt;/p>
&lt;p>注意到 SDM 卷 3 8.2.5 节里的一句话：&lt;/p>
&lt;blockquote>
&lt;p>The SFENCE instruction (introduced to the IA-32 architecture in the Pentium III processor) and the LFENCE and MFENCE instructions (introduced in the Pentium 4 processor) provide memory-ordering and serialization capabilities &lt;strong>for specific types of memory operations.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>也就是说屏障在 x86 下基本只有“特殊”的内存操作才需要。所以先有一个概念：x86“常规”的指令下不是很需要内存屏障。那么我们继续往下就能看到这三条指令的定义：&lt;/p>
&lt;blockquote>
&lt;p>The SFENCE, LFENCE, and MFENCE instructions provide a performance-efficient way of ensuring load and store memory ordering between routines that &lt;strong>produce weakly-ordered results&lt;/strong> and routines that consume that data. The functions of these instructions are as follows:&lt;/p>
&lt;ul>
&lt;li>SFENCE — Serializes all store (write) operations that occurred prior to the SFENCE instruction in the program instruction stream, but does not affect load operations.&lt;/li>
&lt;li>LFENCE — Serializes all load (read) operations that occurred prior to the LFENCE instruction in the program instruction stream, but does not affect store operations.2&lt;/li>
&lt;li>MFENCE — Serializes all store and load operations that occurred prior to the MFENCE instruction in the program instruction stream.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>2. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes. As a result, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible. Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until the LFENCE completes.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>上面加粗的那句“produce weakly-ordered results”，其实也说明了 x86 不仅仅只有 TSO，为了性能它也有更弱的内存模型（如 ARM、RISC-V 般的）。&lt;/p>
&lt;p>回归正题，稍微地阐述一下这三条内存屏障指令：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>SFENCE&lt;/code> 会保证该指令之前的所有 Store 操作不会“跨过”该指令（可能也是“Serializes”的意思？），但是不对 Load 做任何保证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LFENCE&lt;/code> 则保证该指令之前的所有 Load 操作不会“跨过”该指令，也同样不对 Store 做任何保证；注意这里带了一条尾注，指明 &lt;code>LFENCE&lt;/code> 不仅仅能同步数据，也能同步指令，在其他指令没有执行完前不会执行 &lt;code>LFENCE&lt;/code>，所以在一个&lt;a href="https://www.zhihu.com/question/29465982/answer/44465936">知乎回答&lt;/a>说明了这个特性被用在了内核 &lt;code>RDTSC&lt;/code> 之前，以获取更加精确的时钟。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MFENCE&lt;/code> 则会保证之前所有的 Store/Load 操作都不会“跨过”该指令；注意在汇编的世界中（我认为）单条指令永远不等价于多条指令的“和”，例如这里的 &lt;code>MFENCE != SFENCE + LFENCE&lt;/code>，原因就是“原子性”，如果用 &lt;code>SFENCE + LFENCE&lt;/code> 替代 &lt;code>MFENCE&lt;/code> 的话，有个比较大的问题就是两条指令中间有可能存在一定的“空窗期”：在两条指令中间，虽然 &lt;code>SFENCE&lt;/code> 保证了当前核心之前的所有 Store 指令都完成了，但是现在空窗期间（执行 &lt;code>LFENCE&lt;/code> 前）我们已经不能再保证 Store-Store 序了，因为其他 CPU 可能会执行任何的读写操作。这一点在 &lt;a href="https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/#storeload">Preshing 的文章&lt;/a>中也提及到了：&lt;/p>
&lt;blockquote>
&lt;p>However, those two barrier types are insufficient. Remember, the push operation may be delayed for an arbitrary number of instructions, and the pull operation might not pull from the head revision.&lt;/p>
&lt;/blockquote>
&lt;p>所以在汇编上我们必须要有一个 single instrument 来保证 atomicity，这跟 &lt;code>inc&lt;/code>、&lt;code>xchg&lt;/code> 等“混合”指令的作用是类似的，虽然它们都能拆分成多个指令，但是为了保证原子性必须要提供（就算非常精简以及 weakly-ordered 的 RISC-V 架构依然存在着 &lt;code>xchg&lt;/code> 这样的指令，来保证原子性）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>总而言之，通常操作下我们并不需要关心 x86 的内存屏障，因为它已经“足够的强”了，但是面对其他情况下依然需要屏障。&lt;/p>
&lt;p>P.S. 比较有意思的一段话：&lt;/p>
&lt;blockquote>
&lt;p>Intel does not guarantee that future processors will support this model.&lt;/p>
&lt;/blockquote>
&lt;p>看来 Intel 也非常想废弃掉 TSO 啊（笑）。&lt;/p>
&lt;h2 id="sequentially-consistent">Sequentially Consistent&lt;/h2>
&lt;p>内存屏障的其中一个作用，就是将 TSO 内存序变为更强的 SC 内存序，具体做法参考 &lt;a href="https://stackoverflow.com/a/27635527">StackOverflow 的答案&lt;/a>，里面列出了四种做法：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>&lt;code>LOAD&lt;/code> (without fence) and &lt;code>STORE&lt;/code> + &lt;code>MFENCE&lt;/code>&lt;/li>
&lt;li>&lt;code>LOAD&lt;/code> (without fence) and &lt;code>LOCK XCHG&lt;/code>&lt;/li>
&lt;li>&lt;code>MFENCE&lt;/code> + &lt;code>LOAD&lt;/code> and &lt;code>STORE&lt;/code> (without fence)&lt;/li>
&lt;li>&lt;code>LOCK XADD&lt;/code> ( 0 ) and &lt;code>STORE&lt;/code> (without fence)&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>并且指出 GCC 使用的就是方法 1，也就是 &lt;code>STORE + MFENCE&lt;/code> 就能将 TSO 转变为 SC。这个比较好理解，因为 &lt;code>MFENCE&lt;/code> 保证了指令之前的&lt;strong>所有读写&lt;/strong>操作都对其他核心可见，那么如果我们每次写的时候都执行一次 &lt;code>MFENCE&lt;/code>，就意味着每次写完就去强制读写可见，那么后面的读就必定只会读到最新的指。另外因为 SC 要保证 StoreLoad，所以就必须要 &lt;code>MFENCE&lt;/code>（？）。&lt;/p>
&lt;h2 id="non-temporal">Non-Temporal&lt;/h2>
&lt;p>上面提到了对于 NT（Non-Temporal）操作，我们是不能保证 Store-Store 序的，也就是说一个 NT 指令后立刻接上另外的 Store 指令，那么最终的结果是无法确定的，这也是 x86 中 relaxed-order 的体现。所以对于所有的 NT 指令，都建议带上 &lt;code>SFENCE&lt;/code> 内存屏障。&lt;/p>
&lt;blockquote>
&lt;p>Non-Temporal SSE instructions (MOVNTI, MOVNTQ, etc.), don&amp;rsquo;t follow the normal cache-coherency rules. Therefore non-temporal stores must be followed by an SFENCE instruction in order for their results to be seen by other processors in a timely fashion.&lt;/p>
&lt;p>When data is produced and not (immediately) consumed again, the fact that memory store operations read a full cache line first and then modify the cached data is detrimental to performance. This operation pushes data out of the caches which might be needed again in favor of data which will not be used soon. This is especially true for large data structures, like matrices, which are filled and then used later. Before the last element of the matrix is filled the sheer size evicts the first elements, making caching of the writes ineffective.&lt;/p>
&lt;p>For this and similar situations, processors provide support for non-temporal write operations. Non-temporal in this context means the data will not be reused soon, so there is no reason to cache it. These non-temporal write operations do not read a cache line and then modify it; instead, the new content is directly written to memory.&lt;/p>
&lt;p>Source: &lt;a href="http://lwn.net/Articles/255364/">http://lwn.net/Articles/255364/&lt;/a> &lt;a href="https://stackoverflow.com/a/37092">https://stackoverflow.com/a/37092&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>NT 与否其实是跟 cache 有很大关系，这里的解释说是 Non-Temporal 的所有操作都不走 cache（所以才叫“非临时”？）。还是翻一下 SDM 吧，首先直接找到 &lt;code>MOVNTDQA&lt;/code> 的指令介绍吧，在卷 2 4.3 中，摘录关于 Non-Temporal 的部分：&lt;/p>
&lt;blockquote>
&lt;p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when reading the data from memory. Using this protocol, the processor does not read the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being read can override the non-temporal hint, if the memory address specified for the non-temporal read is not a WC memory region. Information on non-temporal reads and writes can be found in “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the Intel® 64 and IA-32 Architecture Software Developer’s Manual, Volume 3A.&lt;/p>
&lt;p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with a MFENCE instruction should be used in conjunction with MOVNTDQA instructions if multiple processors might use different memory types for the referenced memory locations or to synchronize reads of a processor with writes by other agents in the system. A processor’s implementation of the streaming load hint does not override the effective memory type, but the implementation of the hint is processor dependent. For example, a processor implementation may choose to ignore the hint and process the instruction as a normal MOVDQA for any memory type. Alternatively, another implementation may optimize cache reads generated by MOVNTDQA on WB memory type to reduce cache evictions.&lt;/p>
&lt;/blockquote>
&lt;p>这里简要地说明了这个指令的一些细节，例如它的作用就是将内存中的数据读到寄存器中，但是不经过缓存层（也不触发任何的 fetch），第二段则指出了该指令工作在 weakly-ordered 的内存序下，因此需要借助前文说的内存屏障来保证可见性（以及顺序性）。顺便这里也指路到了 SDM 卷 1 10.4.6.2（跟原文的卷号对不上，标错了？）：&lt;/p>
&lt;blockquote>
&lt;p>Data referenced by a program can be temporal (data will be used again) or non-temporal (data will be referenced once and not reused in the immediate future). For example, program code is generally temporal, whereas, multimedia data, such as the display list in a 3-D graphics application, is often non-temporal. &lt;strong>To make efficient use of the processor’s caches, it is generally desirable to cache temporal data and not cache non-temporal data.&lt;/strong> Overloading the processor’s caches with non-temporal data is sometimes referred to as “polluting the caches.” The SSE and SSE2 cacheability control instructions enable a program to write non-temporal data to memory in a manner that minimizes pollution of caches.&lt;/p>
&lt;/blockquote>
&lt;p>也就是说 NT 宽泛来说（概念性）指的就是不会立刻被使用到的数据，也因此出于性能考虑也就不再进行缓存，将缓存让给 temporal data。因此从实现角度来说 NT 就是不经过缓存的数据，考据终了。&lt;/p>
&lt;p>P.S. 在 SDM 卷 3 11.3 中能找到所有的 Memory Types 和相关解释。不贴原文了，整理（粗略地理解）了一下：&lt;/p>
&lt;ul>
&lt;li>Write Combining (WC)：对于一些无法被缓存（cache）的项目，会存在一个专门的 buffer（write combining buffer）来收集并“聚合”（combine）这些读写操作并推迟写入，以此来减少内存（或者 I/O）的读写次数；一些 serializing 指令（如上面提到的 &lt;code>SFENCE&lt;/code>、&lt;code>MFENCE&lt;/code> 以及 &lt;code>CPUID&lt;/code> 等）会强行落地并清空 WC Cache。更多关于 WC Buffer 可以参考 &lt;a href="https://stackoverflow.com/a/49961612">StackOverflow 上的答案&lt;/a>，比较复杂，我也没仔细地去看了 orz。&lt;/li>
&lt;li>Write-through (WT)：所有的 Load/Store 都走 cache，但是每次在往 cache 中写入（Store）时都会直接同步到内存中；读取（Load）则依然会从 cache 中读取。因此 WT 比较适合写不敏感，但是要求与内存保持同步的一些场景（I/O？）。&lt;/li>
&lt;li>Write-back (WB)：所有的 Load/Store 都走 cache，数据会保持在 cache 中直到缓存策略决定该何时写回到内存。这就是我们最常用（也是性能最好的）一种 cache 模式。但是对于 I/O 等需要访问内存的外设（device）肯定就需要考虑一致性的问题了，同时也需要考虑缓存一致性的问题（cache coherency）。&lt;/li>
&lt;li>Write protected (WP)：只对 Load 操作走 cache，所有的 Store 的操作都会让缓存失效。&lt;/li>
&lt;/ul>
&lt;p>P.P.S. 有一个 &lt;code>PREFETCH&lt;/code> 指令可以显式地将部分内存载入到缓存中，这也是在内核代码里看到很多 prefetch 的原理。具体可以看指令说明。&lt;/p>
&lt;h2 id="follymemcpys">folly/memcpy.S&lt;/h2>
&lt;p>这里我的兴趣点在于 &lt;code>.L_NON_TEMPORAL_LOOP&lt;/code> 这个 label 上，首先可以找到哪里会跳转到这里来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="line">&lt;span class="cl">&lt;span class="err">//&lt;/span> &lt;span class="nf">This&lt;/span> &lt;span class="nv">threshold&lt;/span> &lt;span class="nv">is&lt;/span> &lt;span class="nv">half&lt;/span> &lt;span class="nv">of&lt;/span> &lt;span class="nv">L1&lt;/span> &lt;span class="nv">cache&lt;/span> &lt;span class="nv">on&lt;/span> &lt;span class="nv">a&lt;/span> &lt;span class="nv">Skylake&lt;/span> &lt;span class="nv">machine&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nv">which&lt;/span> &lt;span class="nv">means&lt;/span> &lt;span class="nv">that&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">//&lt;/span> &lt;span class="nf">potentially&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="nv">l&lt;/span> &lt;span class="nv">of&lt;/span> &lt;span class="nv">L1&lt;/span> &lt;span class="nv">will&lt;/span> &lt;span class="nv">be&lt;/span> &lt;span class="nv">populated&lt;/span> &lt;span class="nv">by&lt;/span> &lt;span class="nv">this&lt;/span> &lt;span class="nv">copy&lt;/span> &lt;span class="nv">once&lt;/span> &lt;span class="nv">it&lt;/span> &lt;span class="nv">is&lt;/span> &lt;span class="nv">executed&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">//&lt;/span> &lt;span class="err">(&lt;/span>&lt;span class="nf">dst&lt;/span> &lt;span class="nv">and&lt;/span> &lt;span class="nv">src&lt;/span> &lt;span class="nv">are&lt;/span> &lt;span class="nv">cached&lt;/span> &lt;span class="nv">for&lt;/span> &lt;span class="nv">temporal&lt;/span> &lt;span class="nv">copies&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span>&lt;span class="nf">define&lt;/span> &lt;span class="nv">NON_TEMPORAL_STORE_THRESHOLD&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="mi">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">cmp&lt;/span> &lt;span class="nv">NON_TEMPORAL_STORE_THRESHOLD&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rdx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">jae&lt;/span> &lt;span class="nv">.L_NON_TEMPORAL_LOOP&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说当我们 &lt;code>memcpy&lt;/code> 的大小超过了 L1 缓存（folly 取了 Skylake 作为基准）后，就不再借助缓存去拷贝了，而是直接利用上述的 &lt;code>MOVNTx&lt;/code> 系列的 NT 指令绕过缓存，实现比较高性能的拷贝：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">.L_NON_TEMPORAL_LOOP:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">testb&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="mi">31&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">si&lt;/span>&lt;span class="nv">l&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">jne&lt;/span> &lt;span class="nv">.L_ALIGNED_DST_LOOP&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">//&lt;/span> &lt;span class="nf">This&lt;/span> &lt;span class="nv">is&lt;/span> &lt;span class="nv">prefetching&lt;/span> &lt;span class="nv">the&lt;/span> &lt;span class="nv">source&lt;/span> &lt;span class="nv">data&lt;/span> &lt;span class="nv">unlike&lt;/span> &lt;span class="nb">AL&lt;/span>&lt;span class="nv">IGNED_DST_LOOP&lt;/span> &lt;span class="nv">which&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">//&lt;/span> &lt;span class="nf">prefetches&lt;/span> &lt;span class="nv">the&lt;/span> &lt;span class="nv">destination&lt;/span> &lt;span class="nv">data.&lt;/span> &lt;span class="nv">This&lt;/span> &lt;span class="nb">ch&lt;/span>&lt;span class="nv">oice&lt;/span> &lt;span class="nv">is&lt;/span> &lt;span class="nv">again&lt;/span> &lt;span class="nv">informed&lt;/span> &lt;span class="nv">by&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">//&lt;/span> &lt;span class="nf">benchmarks.&lt;/span> &lt;span class="nv">With&lt;/span> &lt;span class="nv">a&lt;/span> &lt;span class="nv">non&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nv">temporal&lt;/span> &lt;span class="nv">store&lt;/span> &lt;span class="nv">the&lt;/span> &lt;span class="nv">entirety&lt;/span> &lt;span class="nv">of&lt;/span> &lt;span class="nv">the&lt;/span> &lt;span class="nv">cache&lt;/span> &lt;span class="nv">line&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">//&lt;/span> &lt;span class="nf">is&lt;/span> &lt;span class="nv">being&lt;/span> &lt;span class="nv">written&lt;/span> &lt;span class="nv">so&lt;/span> &lt;span class="nv">the&lt;/span> &lt;span class="nv">previous&lt;/span> &lt;span class="nv">data&lt;/span> &lt;span class="nv">can&lt;/span> &lt;span class="nv">be&lt;/span> &lt;span class="nb">di&lt;/span>&lt;span class="nv">scarded&lt;/span> &lt;span class="nv">without&lt;/span> &lt;span class="nv">being&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">//&lt;/span> &lt;span class="nf">fetched.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">prefetchnta&lt;/span> &lt;span class="mi">128&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">prefetchnta&lt;/span> &lt;span class="mi">196&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">vmovntdqa&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">ymm0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">vmovntdqa&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">ymm1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">vmovntdqa&lt;/span> &lt;span class="mi">64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">ymm2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">vmovntdqa&lt;/span> &lt;span class="mi">96&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">ymm3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">add&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">vmovntdq&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">ymm0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rdi&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">vmovntdq&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">ymm1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rdi&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">vmovntdq&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">ymm2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rdi&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">vmovntdq&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">ymm3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">96&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">rdi&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">add&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rdi&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">cmp&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nv">r8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">jb&lt;/span> &lt;span class="nv">.L_NON_TEMPORAL_LOOP&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">sfence&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">jmp&lt;/span> &lt;span class="nv">.L_ALIGNED_DST_LOOP_END&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 folly 借助 &lt;code>movntdqa&lt;/code> 指令将数据读入到 AVX 寄存器 &lt;code>ymmX&lt;/code> 中，再使用 &lt;code>movntdq&lt;/code> 将寄存器的值写回到内存，并循环。最后，注意到这里还有个 &lt;code>sfence&lt;/code> 指令，保证在拷贝完后数据对其他核心可见（但是拷贝途中无法保证，所以可能需要调用着确保不会出现 data race），符合 SDM 上的定义。&lt;/p>
&lt;p>到此，基本上我们也理解了 x86 的 TSO 内存序（比 SC 弱的地方在于只能保证同一个地址的 Store-Load，但是可以通过 &lt;code>MFENCE&lt;/code> 指令做到所有地址的 Store-Load 以实现 SC）、x86 的内存屏障的作用（通常程序中因为 TSO 的存在没有什么作用，但是对于如 NT 系列的特殊指令需要 weakly-ordered memory，就必须使用内存屏障了；不过为了程序的 portable 性，还是尽量地加上内存屏障操作，也能加深理解）。现在，我们再来尝试理解（困扰我多年的.jpg）C++ &lt;code>std::memory_order&lt;/code> 了。&lt;/p>
&lt;h2 id="cache">Cache&lt;/h2>
&lt;p>关于 Memory Order，偶尔还是会提到缓存，因为像 Intel x86 等主流实现来说，基本都会带有缓存。那么我们对内存进行操作的时候就会存在一个中间的 cache 状态，这可能会导致内存序出现一些小小的差异（例如如果有一个简单的 cache，我们往同一个内存地址多次写入数据，那么实际就只是一直在往 cache 中写入数据，没有&lt;em>及时地&lt;/em>写回到内存中去，其他 CPU 就无法观测，也就无法保证 Store-Load 等内存序了）。&lt;/p>
&lt;p>这个问题就交由缓存一致性算法来解决，最终实现的效果就是在 x86 下无论我们怎么操作 cache 和内存，只要地址相同，就能保证其他 CPU 始终能观测到最新值，从而保证 Store-Load 序正确（上面的例子也就不会出现无法观测的问题）。而对于其他架构而言，应该也需要实现类似的效果，起码是需要有处理 atomic 的能力，即能让别的 CPU 观测到对内存操作的变化。&lt;/p>
&lt;p>对于 x86 而言，常用的缓存一致性协议是 MESI，这个协议比较重要的就是“嗅探机制”（snoop），也是通过 snoop 通过总线来得知其他 CPU 的操作；具体可以查看&lt;a href="https://en.wikipedia.org/wiki/MESI_protocol">维基百科 MESI&lt;/a> 的页面，这部分我暂时还没深入地去了解，大概只知道这些了（逃。&lt;/p>
&lt;h2 id="编译器的指令重排">编译器的指令重排&lt;/h2>
&lt;p>有时候在大量存在变量的读写时，编译器会选择性地进行指令重排（例如你能在 GDB 中发现很多“诡异”的跳转，常常执行到一半的时候跳回到开头执行变量的初始化等），这就是区别于 CPU 指令重排的编译器指令重排。编译器重排基本都是在编译期做的，有两种方式可以抑制：&lt;/p>
&lt;ol>
&lt;li>变量使用 &lt;code>volatile&lt;/code> 关键字，针对的是该变量；&lt;/li>
&lt;li>使用 &lt;code>asm volatile(&amp;quot;&amp;quot; ::: &amp;quot;memory&amp;quot;)&lt;/code>，针对的是该语句上下的重排，跟 CPU 的内存屏障很像，就是避免语句之前的读写操作重新排序到该语句之后。另外语句起作用的地方是 &lt;code>&amp;quot;memory&amp;quot;&lt;/code>，所以第一个参数无论是任何汇编指令都会有抑制编译器重排的效果。&lt;/li>
&lt;/ol>
&lt;p>大概也就是这些了，文章重点依然在 x86 上，暂时不讨论编译器了（其实是不会 QAQ）。&lt;/p>
&lt;p>后续会写一篇 C/C++ 的 Memory Order，来对“真实世界”中的内存模型（希望能）有一个更稍微透彻的理解&lt;del>以及咕咕咕&lt;/del>。&lt;/p></description></item><item><title>关于</title><link>https://error.iorw.io/about/</link><pubDate>Fri, 09 Dec 2022 22:54:54 +0800</pubDate><guid>https://error.iorw.io/about/</guid><description>&lt;h2 id="me-myself-and-i">Me, Myself, and I&lt;/h2>
&lt;ul>
&lt;li>不太起眼的一只鶸&lt;/li>
&lt;li>装懂以及强答流作者&lt;/li>
&lt;li>失业人群&lt;/li>
&lt;/ul>
&lt;h2 id="blog">b:log().&lt;/h2>
&lt;ul>
&lt;li>只是文章的搬运工&lt;/li>
&lt;li>多数情况下都是在胡说&lt;/li>
&lt;li>其他情况下是在乱说&lt;/li>
&lt;/ul>
&lt;h2 id="friends">Friends&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.zzfly.net">烟花易冷&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://virgilg72.github.io/">VirgilG72&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.yukicat.net/">雪猫社&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>乱谈 Monad</title><link>https://error.iorw.io/2022/12-08-babble-monad/</link><pubDate>Thu, 08 Dec 2022 20:46:25 +0800</pubDate><guid>https://error.iorw.io/2022/12-08-babble-monad/</guid><description>&lt;h2 id="preface">Preface&lt;/h2>
&lt;p>这几天按着我半吊子的 haskell 水平稍微研究了一下 monad，还是有点不是很理解，只能浅浅地谈一谈我自己的想法，错误和纰漏难以避免，所谓乱谈是也。&lt;/p>
&lt;h2 id="the-moand">The Moand&lt;/h2>
&lt;p>这部分尽量会详细地阐述一下&lt;a href="https://www.zhihu.com/question/19635359/answer/172074046">刘月半大神的这篇文章&lt;/a>，适当的改动了一些例子，首先从 &lt;code>Maybe&lt;/code> 的构造函数开始，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">data&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>a&lt;/code> 是一个类型，我们可以“实例化”一个 &lt;code>Maybe Int&lt;/code> 类型出来等等，并且存在两个“构造器”，&lt;code>Just&lt;/code> 和 &lt;code>Nothing&lt;/code>。例如我们可以构造一个 &lt;code>safeDiv&lt;/code> 函数，这个函数作用是保证在遇到除零错误时不会让程序 crash，而是返回一个 &lt;code>Maybe Int&lt;/code> 类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">safeDiv&lt;/span> &lt;span class="ow">::&lt;/span> &lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">safeDiv&lt;/span> &lt;span class="kr">_&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">safeDiv&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="p">`&lt;/span>&lt;span class="n">div&lt;/span>&lt;span class="p">`&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">-- 除法运算符 / 不能作用在 Int 上&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们希望一个比较复杂的除法运算中，都能保证除零安全的话，我们可能会写出下面这样的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 安全地计算 a/b/c/d/e&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">case&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="kr">of&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Just&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kr">case&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="kr">of&lt;/span> &lt;span class="c1">-- 如果 b != 0，能够继续进行除法，尝试计算 (a/b)/c&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Just&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kr">case&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">d&lt;/span> &lt;span class="kr">of&lt;/span> &lt;span class="c1">-- 如果 c != 0，继续尝试计算 (a/b/c)/d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Just&lt;/span> &lt;span class="n">z&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">z&lt;/span> &lt;span class="n">e&lt;/span> &lt;span class="c1">-- 如果 d != 0，继续尝试计算 (a/b/c/d)/e&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到代码非常的啰嗦，而且看着很难受（对应过程式语言就是一层又一层的 if 嵌套），有没有办法能优化呢？实际上上面的例子中，我们可以从几个 &lt;code>case&lt;/code> 中提取出一些公共特征（伪代码，&lt;code>{Int}&lt;/code> 表示此处的变量类型为 &lt;code>Int&lt;/code>）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 将 safeDiv x c 使用 \x -&amp;gt; safeDiv x c 替换，即可得到最简洁的 Int -&amp;gt; Maybe Int 函数；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 因为被 lambda 捕获的量基本都能被视作常量（？）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">case&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="kr">of&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Just&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>给上面的类型附上名字和类型，就成了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&amp;#39;&lt;/span> &lt;span class="ow">::&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&amp;#39;&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="n">m&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kr">case&lt;/span> &lt;span class="n">m&lt;/span> &lt;span class="kr">of&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Just&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到这里我们就得到了一个 &lt;code>Maybe&lt;/code> 的所谓 functor（函子），&lt;/p>
&lt;blockquote>
&lt;p>Maybe 之所以是函子，是因为它可以通过 fmap（functor map）把所有的函数拎到「Maybe 空间」里。&lt;/p>
&lt;/blockquote>
&lt;p>有了函子之后，我们尝试把这个抽象应用到我们的例子上去看看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">let&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="c1">-- 第一层 a/b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">y&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">fmap&amp;#39;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="c1">-- 第二层 (a/b)/c&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">fmap&amp;#39;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="c1">-- 第三层 (a/b/c)/d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fmap&amp;#39;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">z&lt;/span> &lt;span class="c1">-- 第四层 (a/b/c/d)/e&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>抛开性能不谈（雾），这种写法看起来已经舒服很多了，但是感觉还是“存在进步空间”的样子。也的确，haskell 给我们提供了一个 &lt;code>&amp;gt;&amp;gt;=&lt;/code> 运算符，可以让我们来实现 &lt;code>fmap&lt;/code>，并且再次优化上面的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 这是一个中缀运算符，这个例子中 (&amp;gt;&amp;gt;=) m f 等价于 m &amp;gt;&amp;gt;= f；定义与 fmap&amp;#39; 完全一致&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;=&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">::&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;=&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">m&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kr">case&lt;/span> &lt;span class="n">m&lt;/span> &lt;span class="kr">of&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Just&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- the optimzed version&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">safeDiv&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">w&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="n">d&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好像，有点反向优化了？没事，haskell 为这个模式设计了 &lt;code>do&lt;/code> 语法糖：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">val&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kr">do&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="ow">&amp;lt;-&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">y&lt;/span> &lt;span class="ow">&amp;lt;-&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">c&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span> &lt;span class="ow">&amp;lt;-&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">z&lt;/span> &lt;span class="n">e&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>简洁，好看，elegant！这就是“所谓的” monad 了！当然，因为标准库里&lt;a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Maybe.html">已经提供&lt;/a>了 &lt;code>instance Monad Maybe&lt;/code> 了，所以最后的代码中，我们不需要再定义任何其他函数了，只需要保留 &lt;code>safeDiv&lt;/code> 就可以了。当然我们也能自行实现各种各样的 functor，有点像是 OOP 的接口一样（笑）。&lt;/p>
&lt;h2 id="functor-and-monad">Functor and Monad&lt;/h2>
&lt;p>上面的例子中，我们的 &lt;code>fmap'&lt;/code> 是自己定义的，而官方针对 &lt;a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/src/GHC.Base.html">&lt;code>Maybe&lt;/code> 实现的 &lt;code>fmap&lt;/code>&lt;/a> 是不太一样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- | @since 2.01&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">instance&lt;/span> &lt;span class="kt">Functor&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kr">where&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fmap&lt;/span> &lt;span class="kr">_&lt;/span> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fmap&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">-- notice here!&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们的例子中模式匹配项是 &lt;code>Just x -&amp;gt; f x&lt;/code>，但是官方的却是 &lt;code>Just a -&amp;gt; Just (f a)&lt;/code>，后者其实才是标准格式；&lt;code>safeDiv&lt;/code> 这个例子不同是因为我们完全是根据函数类型来“特化”的一个：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- safeDiv version of fmap&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&lt;/span> &lt;span class="ow">::&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kt">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- haskell fmap, f is functor, eq to `Maybe`&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&lt;/span> &lt;span class="ow">::&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到差异在第一个参数类型上。这里提这个区别是因为这里要开始区分 functor 和 monad 了。前文的例子中可能大家会觉得 monad 跟 functor 是一回事，实际上是存在差异的。Haskell 定义了 &lt;a href="https://wiki.haskell.org/Functor-Applicative-Monad_Proposal">Functor-Applicative-Monad&lt;/a> 结构，简而言之就是 applicative 必定是 functor，monad 必定是 applicative，三者有继承关系，所以 functor 其实是性质是比较弱的。&lt;/p>
&lt;p>这部分主要会根据哔站&lt;a href="https://www.bilibili.com/video/BV1qh411q7cS">鹤翔万里的视频&lt;/a>进行一定的细致阐述，也会对前文刘月半大神的文章进行再补充。先从 functor 开始吧，它的作用看上面函数定义就能略知一二了，给定一个一般的函数，让它去处理“装箱”后的类型，并且返回一个同样被装箱了的类型，看 haskell 的 &lt;code>Maybe&lt;/code> 实现就知道了，这里贴出来视频的几个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- instance Functor Maybe&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- instance Functor []&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然 functor 根据定义，它的局限性就在于只能处理值，对于函数，它只会返回一个装箱后的函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且我们无法继续往下进行了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="err">🤯&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时就需要引入 applicative 来处理了，直接看官方定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- | @since 2.01&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">instance&lt;/span> &lt;span class="kt">Applicative&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kr">where&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pure&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Just&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="o">&amp;lt;*&amp;gt;&lt;/span> &lt;span class="n">m&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">fmap&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="n">m&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="o">&amp;lt;*&amp;gt;&lt;/span> &lt;span class="n">_m&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">liftA2&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">liftA2&lt;/span> &lt;span class="kr">_&lt;/span> &lt;span class="kr">_&lt;/span> &lt;span class="kr">_&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Just&lt;/span> &lt;span class="n">_m1&lt;/span> &lt;span class="o">*&amp;gt;&lt;/span> &lt;span class="n">m2&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">m2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="o">*&amp;gt;&lt;/span> &lt;span class="n">_m2&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主要关注 &lt;code>&amp;lt;*&amp;gt;&lt;/code> 这个函数（读作 apply），可以看到 applicative 将 &lt;code>Just (+3)&lt;/code> 里面的 &lt;code>(+3)&lt;/code> 函数给取出来了，然后通过 &lt;code>fmap&lt;/code> 应用函数，这样得到的结果依然是个 &lt;code>Maybe&lt;/code> 类型，it just works。&lt;/p>
&lt;p>同样，贴上视频中的几个例子当作 memo：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- instance Applicative Maybe&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">Just&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;*&amp;gt;&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- instance Applicative []&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[(&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)]&lt;/span> &lt;span class="o">&amp;lt;*&amp;gt;&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们把前文例子中 &lt;code>safeDiv&lt;/code> 里的 &lt;code>fmap'&lt;/code> 删去，那么下面这个函数就会开始出类型错误：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- without customized fmap function&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">let&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="c1">-- 第一层 a/b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">y&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="c1">-- 第二层 (a/b)/c&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="c1">-- 第三层 (a/b/c)/d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">z&lt;/span> &lt;span class="c1">-- 第四层 (a/b/c/d)/e&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原因前文说了，&lt;code>fmap&lt;/code> 其实返回的是 &lt;code>Just (f a)&lt;/code>，也就是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">\&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这就有点难受了，不是我们预期想要的 &lt;code>Just 10&lt;/code>。这种情况下就需要使用 monad 了，也就是上面定义中 &lt;code>&amp;gt;&amp;gt;=&lt;/code>（读作 bind）来进行处理了，也是直接看官方代码吧：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- | @since 2.01&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">instance&lt;/span> &lt;span class="kt">Monad&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="kr">where&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">Nothing&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="kr">_&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对比官方 &lt;code>fmap&lt;/code> 就能看到，monad 的 instance 中不再是 &lt;code>Just (k x)&lt;/code>，而是简介、明了的 &lt;code>k x&lt;/code>，neat。这也是跟我们在 &lt;code>safeDiv&lt;/code> 中实现的 &lt;code>&amp;gt;&amp;gt;=&lt;/code> 版本完全等价，所以它就是一个 monad。&lt;/p>
&lt;p>依然，贴上一些视频中的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">Just&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="nf">\&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Just&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>个人理解，无论是 functor、applicative 还是 monad，它们本质上都是为了更好地处理“被装箱的类型”。而 haskell 比较推崇这种盒子模式，很多类型像 &lt;code>Maybe a&lt;/code>、&lt;code>IO a&lt;/code> 这种，都实现了 monad 的 bind 运算符。&lt;/p>
&lt;p>比如 Haskell 里常用的数组展开，其实也是借助 functor 来完成的，来自&lt;a href="https://zhuanlan.zhihu.com/p/39734882">评论区的 Narc 大神&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">&amp;lt;-&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="ow">&amp;lt;-&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- desuger&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="nf">\&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="nf">\&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="n">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外 JavaScript 的 &lt;code>Promise&lt;/code> 也是跟 monad 有点“异曲同工”之妙的，毕竟 lazy eval 能看作是异步（。&lt;/p>
&lt;h2 id="myth">Myth&lt;/h2>
&lt;p>我个人依然有一些迷思，可能需要系统地学习下范畴论才能解惑了。&lt;/p>
&lt;ol>
&lt;li>都说 monad 能隔离副作用，但是我看下，感觉跟闭包差不多？将所有状态装箱到一个闭包中，当然外部无法修改，&lt;a href="https://stackoverflow.com/a/79077">Stack Overflow 上也有讨论&lt;/a>，说区别在于“A monad is (roughly) more like a context in which functions can be chained together sequentially, and controls how data is passed from one function to the next.”&lt;/li>
&lt;li>对用法依然不是很清晰，暂时的想法是，monad 就是用来处理“盒子”的，side effect 可以装进盒子中，error handling 也可以装进去，等等；并且 monad 可以“传递”（不同于 closure 只能捕获函数内的，monad 可以捕获整个链式调用上的结果)，加上 &lt;code>return&lt;/code> 函数的辅助，容易实现 chain call，并且 chain 上的函数都共享整个 context？&lt;/li>
&lt;li>一个自函子范畴上的幺半群。。嗯，还是不太懂😂&lt;/li>
&lt;/ol>
&lt;p>还有，原知乎帖子里讲述了一个 &lt;code>join&lt;/code> 操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-haskell" data-lang="haskell">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">let&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">safeDiv&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">y&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">fmap&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">safeDiv&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fmap&lt;/span> &lt;span class="o">.&lt;/span> &lt;span class="n">fmap&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">safeDiv&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">in&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fmap&lt;/span> &lt;span class="o">.&lt;/span> &lt;span class="n">fmap&lt;/span> &lt;span class="o">.&lt;/span> &lt;span class="n">fmap&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">safeDiv&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">z&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">join&lt;/span> &lt;span class="ow">::&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Maybe&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="n">a&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">join&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">Just&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">join&lt;/span> &lt;span class="kt">Nothing&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="kt">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;=&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">::&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">-&amp;gt;&lt;/span> &lt;span class="kt">Maybe&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;=&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">mbx&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="ow">=&lt;/span> &lt;span class="n">join&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fmap&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="n">mbx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这一部分我暂时还不是很懂，答主给的例子中那一串 &lt;code>fmap&lt;/code> 我暂时还是没能推导出类型出来（不太熟悉 &lt;code>.&lt;/code> 操作符，是 haskell 超高校级的新手了）。To be continued。&lt;/p>
&lt;p>其实自己还是有挺多地方不懂的，不过 haskell 可能暂时不会再学习了，目前对 erlang 更有兴趣一些，学一门语言等于学完了并发范式，不香吗不香吗（其实主要是数学太渣了，看了一小会范畴论就已经开始歇菜了🤧）。&lt;/p></description></item></channel></rss>