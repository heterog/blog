<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Heaven Is</title><link>https://error.iorw.io/</link><description>Recent content on Heaven Is</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>unlicense yet.</copyright><lastBuildDate>Sat, 17 Dec 2022 17:10:42 +0800</lastBuildDate><atom:link href="https://error.iorw.io/" rel="self" type="application/rss+xml"/><item><title>浅入 x86 内存序</title><link>https://error.iorw.io/2022/12-17-memory-order-in-x86/</link><pubDate>Sat, 17 Dec 2022 17:10:42 +0800</pubDate><guid>https://error.iorw.io/2022/12-17-memory-order-in-x86/</guid><description>&lt;pre tabindex="0">&lt;code class="language-log" data-lang="log">[WARN] Using deprecated method `memory-order&amp;#39;, it might be removed in the future.
&lt;/code>&lt;/pre>&lt;h2 id="内存序memory-order">内存序（Memory Order）&lt;/h2>
&lt;p>在 x86 中，内存屏障通常是不需要的，因为 x86 是比较严格的 TSO（不完全，因为始终没有“官宣”，但是按照定义来说比较接近，而且不同的厂商如 AMD/Intel 之间的实现也存在略微差别）。&lt;/p>
&lt;p>百度找到了一份 &lt;a href="https://www.cis.upenn.edu/~devietti/classes/cis601-spring2016/sc_tso.pdf">sc_tso.pdf&lt;/a> 讲述了 TSO 的一些特点，其中包括程序顺序（program order）与内存序（memory order）之间的关系：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Whether they are to the same or different addresses (i.e., a=b or a≠b).If L(a) &amp;lt;p L(b) ⇒ L(a) &amp;lt;m L(b) /* Load→Load */If L(a) &amp;lt;p S(b) ⇒ L(a) &amp;lt;m S(b) /* Load→Store */If S(a) &amp;lt;p S(b) ⇒ S(a) &amp;lt;m S(b) /* Store→Store */&lt;del>If S(a) &amp;lt;p L(b) ⇒ S(a) &amp;lt;m L(b)&lt;/del> /* Store→Load */: Enable FIFO write buffer&lt;/li>
&lt;li>When to the same address, every load gets its value from the last store before it.
If S(a) &amp;lt;p L(a) ⇒ S(a) &amp;lt;m L(a) /* Store→Load */&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>其中 &lt;code>&amp;lt;p&lt;/code> 表示的是程序顺序下的先后关系，而 &lt;code>&amp;lt;m&lt;/code> 则是内存顺序下的先后关系。&lt;strong>注意这里不考虑编译器进行过的指令重排，这里的程序顺序也是编译完后的汇编顺序&lt;/strong>。&lt;/p>
&lt;p>内存序其实不一定要完全写回到内存才算，只要其他 CPU 能看到最终更改就行了（globally visible），例如最常见的 Store-Load，假如 Store(a, 100) 执行完后，那么其他任意的核心在执行 Load(a) 时结果都必须保证为 100；但是这不一定意味着内存中的 a 就一定是 100，有可能它还只是在 L3 Cache 中。&lt;/p>
&lt;p>上面的引用处我还是稍微修改了一点，为了方便阅读；可以看到，对于所有的 Load/Store，三种 Load-Load、Load-Store、Store-Store 都是 SC 的，即内存序就是程序序。但是之所以我们说 TSO 要弱于 SC，是因为对于 Store-Load 这样的操作并没有这么严格，Store-Load 只有在当读写同一个地址（同一片内存时）才是成立的；读写不同内存时 Store-Load 下程序序是不能等价于内存序的。&lt;/p>
&lt;p>能作证这一点的还有 &lt;a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">Intel SDM&lt;/a> Volume 3 8.2.2 部分，这里也摘录了一下：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Reads are not reordered with other reads.&lt;/li>
&lt;li>Writes are not reordered with older reads.&lt;/li>
&lt;li>Writes to memory are not reordered with other writes, with the following exceptions:
&lt;ul>
&lt;li>streaming stores (writes) executed with the non-temporal move instructions (MOVNTI, MOVNTQ, MOVNTDQ, MOVNTPS, and MOVNTPD); and&lt;/li>
&lt;li>string operations (see Section 8.2.4.1).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>No write to memory may be reordered with an execution of the CLFLUSH instruction; a write may be reordered with an execution of the CLFLUSHOPT instruction that flushes a cache line other than the one being written.1 Executions of the CLFLUSH instruction are not reordered with each other. Executions of CLFLUSHOPT that access different cache lines may be reordered with each other. An execution of CLFLUSHOPT may be reordered with an execution of CLFLUSH that accesses a different cache line.&lt;/li>
&lt;li>Reads may be reordered with older writes to different locations but not with older writes to the same location.&lt;/li>
&lt;li>Reads or writes cannot be reordered with I/O instructions, locked instructions, or serializing instructions.&lt;/li>
&lt;li>Reads cannot pass earlier LFENCE and MFENCE instructions.&lt;/li>
&lt;li>Writes and executions of CLFLUSH and CLFLUSHOPT cannot pass earlier LFENCE, SFENCE, and MFENCE instructions.&lt;/li>
&lt;li>LFENCE instructions cannot pass earlier reads.&lt;/li>
&lt;li>SFENCE instructions cannot pass earlier writes or executions of CLFLUSH and CLFLUSHOPT.&lt;/li>
&lt;li>MFENCE instructions cannot pass earlier reads, writes, or executions of CLFLUSH and CLFLUSHOPT.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>其中比较重要的就是上面的第 1、2、3、5 点。翻译下来就是：&lt;/p>
&lt;ul>
&lt;li>1. Load-Load 下内存序等于程序序（不会被重排）&lt;/li>
&lt;li>2. Load-Store 下内存序等于程序序，注意这里写的是 older reads，也就是说当前 Store 指令（&lt;code>MOV&lt;/code> 等）之前的 Load 指令都不会被重新排序&lt;/li>
&lt;li>3. Store-Store 下内存序等于程序序，例外情况是 non-temporal 和 rep mov 之类的指令（后面会提到，在写一般代码时不会太接触到）&lt;/li>
&lt;li>5. Store-Load 下只有当读写的都是同样的地址时内存序才等于程序序，否则对于不同的地址的读写依然会存在重排&lt;/li>
&lt;/ul>
&lt;p>到这里应该大概就了解了为何说 x86 架构普遍都是 TSO，以及为何 TSO 要弱于 SC。&lt;/p>
&lt;h2 id="多核心">多核心&lt;/h2>
&lt;p>&lt;strong>注意&lt;/strong>上述例子都只在单核心中生效，包括 TSO 这些（写这篇文章的时候好像没考虑到单/多核心问题，可能要回炉重造了 FIXME）。对于多核心系统（multiple-processor），SDM Volume 3 8.2.2 同样也定义了：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Individual processors use the same ordering principles as in a single-processor system.&lt;/li>
&lt;li>Writes by a single processor are observed in the same order by all processors.&lt;/li>
&lt;li>Writes from an individual processor are NOT ordered with respect to the writes from other processors.&lt;/li>
&lt;li>Memory ordering obeys causality (memory ordering respects transitive visibility).&lt;/li>
&lt;li>Any two stores are seen in a consistent order by processors other than those performing the stores&lt;/li>
&lt;li>Locked instructions have a total order.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>重点就是，在多核心的情况下，单核心的写入顺序可以保持不变，但是很可能会穿插进其他核心的写操作。SDM 上附带了一个很好的例子来解释这一行为，考虑三个核心都在同时写入数据：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; Writes from individual processors:
Processor#1 Processor#2 Processor#3
Write A.1 Write A.2 Write A.3
Write B.1 Write B.2 Write B.3
Write C.1 Write C.2 Write C.3
&amp;gt; Actual writes (one of the example) in memory:
Write A.1
Write B.1
Write A.2
Write A.3
Write C.1
Write B.2
Write C.2
Write B.3
Write C.3
&lt;/code>&lt;/pre>&lt;p>P.S. 第四点的“因果律”可能一开始让人觉得有点摸不着头脑，可以参考 &lt;a href="https://stackoverflow.com/a/27374794">Stack Overflow&lt;/a> 的例子来了解，实际上就是保证如果单个变量写入且能被正确观测到，那么前面所有的变量写入都应该可以被观测到。个人理解 x86 在多核心的内存序上相对比较“难预测”，内存序依赖于观测到的值，也就是只有在“看”到了实际的值之后，才能知道哪些变量被正确地写入了。&lt;/p>
&lt;h2 id="一个栗子">一个栗子&lt;/h2>
&lt;p>一个我觉得很有“意思”的例子，来源一个知乎文章，介绍&lt;a href="https://zhuanlan.zhihu.com/p/454564295">内存屏障&lt;/a>所用的，原文代码有点乱，这里重新格式化并稍微精简了一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define _GNU_SOURCE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sched.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;assert.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> x, y, r1, r2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> pthread_barrier_t barrier_start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> pthread_barrier_t barrier_end;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">thread1&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_barrier_wait(&lt;span style="color:#f92672">&amp;amp;&lt;/span>barrier_start);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// run1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r1 &lt;span style="color:#f92672">=&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_barrier_wait(&lt;span style="color:#f92672">&amp;amp;&lt;/span>barrier_end);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">thread2&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_barrier_wait(&lt;span style="color:#f92672">&amp;amp;&lt;/span>barrier_start);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// run2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r2 &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_barrier_wait(&lt;span style="color:#f92672">&amp;amp;&lt;/span>barrier_end);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(pthread_barrier_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>barrier_start, NULL, &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(pthread_barrier_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>barrier_end, NULL, &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_t t1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_t t2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(pthread_create(&lt;span style="color:#f92672">&amp;amp;&lt;/span>t1, NULL, thread1, NULL) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(pthread_create(&lt;span style="color:#f92672">&amp;amp;&lt;/span>t2, NULL, thread2, NULL) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpu_set_t cs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_ZERO(&lt;span style="color:#f92672">&amp;amp;&lt;/span>cs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_SET(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>cs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(pthread_setaffinity_np(t1, &lt;span style="color:#66d9ef">sizeof&lt;/span>(cs), &lt;span style="color:#f92672">&amp;amp;&lt;/span>cs) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_ZERO(&lt;span style="color:#f92672">&amp;amp;&lt;/span>cs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_SET(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>cs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(pthread_setaffinity_np(t2, &lt;span style="color:#66d9ef">sizeof&lt;/span>(cs), &lt;span style="color:#f92672">&amp;amp;&lt;/span>cs) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// start()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> r1 &lt;span style="color:#f92672">=&lt;/span> r2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_barrier_wait(&lt;span style="color:#f92672">&amp;amp;&lt;/span>barrier_start);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_barrier_wait(&lt;span style="color:#f92672">&amp;amp;&lt;/span>barrier_end);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// end()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> assert(&lt;span style="color:#f92672">!&lt;/span>(r1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> r2 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// gcc xxx.c -O2 -pthread &amp;amp;&amp;amp; ./a.out
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据原作者阐述，这段程序必定会产生 &lt;code>end()&lt;/code> 处引发的断言错误。那么我们来对着上面的多核心下的内存模型稍微解释一下吧，根据上面的定义，线程 t1 和线程 t2 同时写入变量 &lt;code>x&lt;/code> 与 &lt;code>y&lt;/code>，那么真实的写入顺序有可能是先写 &lt;code>x&lt;/code> 或是先写 &lt;code>y&lt;/code>；不过重点还是“读”的顺序，按照前文关于 Store-Load 序的解释，&lt;code>r1&lt;/code> 和 &lt;code>r2&lt;/code> &lt;strong>不一定&lt;/strong>会读到写入的值（因为不是同一个核心)，x86 内存模型只保证假设真实内存写入顺序为 &lt;code>x = 1; y = 1&lt;/code>，那么如果 &lt;code>r1&lt;/code> 读到 &lt;code>y == 1&lt;/code>，则 &lt;code>r2&lt;/code> 必定也能读到 &lt;code>x == 1&lt;/code>。&lt;/p>
&lt;p>另外按照 SDM 官方的说法（位于 Volume 3 8.2.3.4），&lt;/p>
&lt;blockquote>
&lt;p>At each processor, the load and the store are to different locations and hence may be reordered. Any interleaving of the operations is thus allowed.One such interleaving has the two loads occurring before the two stores. This would result in each load returning value 0.&lt;/p>
&lt;/blockquote>
&lt;p>也就是说对于一个核心而言，只有在&lt;strong>该核心&lt;/strong>上读写同一地址才是顺序的；否则就算多核心都读写同一地址，中间都有可能发生乱序。这两种解释都是行得通的。&lt;/p>
&lt;p>解决方法可以是下面所述的内存屏障，即在写入 &lt;code>x&lt;/code> 或 &lt;code>y&lt;/code> 后引入内存屏障，保证下一条读指令执行前完成写入，即：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// t1/run1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__asm__ &lt;span style="color:#a6e22e">__volatile__&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;mfence&amp;#34;&lt;/span> &lt;span style="color:#f92672">:::&lt;/span> &lt;span style="color:#e6db74">&amp;#34;memory&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r1 &lt;span style="color:#f92672">=&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// t2/run2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__asm__ &lt;span style="color:#a6e22e">__volatile__&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;mfence&amp;#34;&lt;/span> &lt;span style="color:#f92672">:::&lt;/span> &lt;span style="color:#e6db74">&amp;#34;memory&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r2 &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样一来，所有可能的路径都不再会产生 &lt;code>r1&lt;/code> 和 &lt;code>r2&lt;/code> 同时为零的情况了：&lt;/p>
&lt;ol>
&lt;li>t1 执行到 &lt;code>x = 1&lt;/code>，t2 执行到 &lt;code>mfence&lt;/code>，那么 t1 必然能保证 &lt;code>r1 = y = 1&lt;/code>，因为 t2 使用了 &lt;code>mfence&lt;/code> 强制 CPU 按照 &lt;code>x = 1; r2 = x&lt;/code> 的顺序执行（如果没有 &lt;code>mfence&lt;/code> 就可能会出现 &lt;code>r2 = x; r1 = y; x = 1; y = 1&lt;/code> 的内存读写顺序出现）&lt;/li>
&lt;li>t1 执行到 &lt;code>mfence&lt;/code>，t2 执行到 &lt;code>y = 1&lt;/code>，同样，t2 必然能保证 &lt;code>r2 = x = 1&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>注意 &lt;code>x&lt;/code> 与 &lt;code>y&lt;/code> 是否能够被观测到与指令乱序没有太大关系，内存屏障只保证读写的顺序，但是不保证读写的值是否有效，后者是由 atomic 负责保证的，只是恰巧 x86 下绝大多数读写操作都是原子的，一定要区分好两者的关系 orz。&lt;/p>
&lt;p>另一个粗暴的方法就是所有 mov 操作都带上 lock prefix，保证 total order。&lt;/p>
&lt;p>总而言之，多核心下 x86 内存序能保证的只有写入的顺序，以及“因果律”读到的结果；但是无法保证多核心下读和写的顺序，要保证这种顺序需要依靠内存屏障或是总线锁。&lt;/p>
&lt;h2 id="内存屏障memory-fence">内存屏障（Memory Fence）&lt;/h2>
&lt;p>前文列出的 SDM 卷 3 8.2.2 节里，用了好几个点叙述 &lt;code>xFENCE&lt;/code> 指令，包括 &lt;code>LFENCE&lt;/code>、&lt;code>SFENCE&lt;/code> 和 &lt;code>MFENCE&lt;/code>。&lt;/p>
&lt;p>注意到 SDM 卷 3 8.2.5 节里的一句话：&lt;/p>
&lt;blockquote>
&lt;p>The SFENCE instruction (introduced to the IA-32 architecture in the Pentium III processor) and the LFENCE and MFENCE instructions (introduced in the Pentium 4 processor) provide memory-ordering and serialization capabilities &lt;strong>for specific types of memory operations.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>也就是说屏障在 x86 下基本只有“特殊”的内存操作才需要。所以先有一个概念：x86“常规”的指令下不是很需要内存屏障。那么我们继续往下就能看到这三条指令的定义：&lt;/p>
&lt;blockquote>
&lt;p>The SFENCE, LFENCE, and MFENCE instructions provide a performance-efficient way of ensuring load and store memory ordering between routines that &lt;strong>produce weakly-ordered results&lt;/strong> and routines that consume that data. The functions of these instructions are as follows:&lt;/p>
&lt;ul>
&lt;li>SFENCE — Serializes all store (write) operations that occurred prior to the SFENCE instruction in the program instruction stream, but does not affect load operations.&lt;/li>
&lt;li>LFENCE — Serializes all load (read) operations that occurred prior to the LFENCE instruction in the program instruction stream, but does not affect store operations.2&lt;/li>
&lt;li>MFENCE — Serializes all store and load operations that occurred prior to the MFENCE instruction in the program instruction stream.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>2. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes. As a result, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible. Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until the LFENCE completes.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>上面加粗的那句“produce weakly-ordered results”，其实也说明了 x86 不仅仅只有 TSO，为了性能它也有更弱的内存模型（如 ARM、RISC-V 般的）。&lt;/p>
&lt;p>回归正题，稍微地阐述一下这三条内存屏障指令：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>SFENCE&lt;/code> 会保证该指令之前的所有 Store 操作不会“跨过”该指令（可能也是“Serializes”的意思？），但是不对 Load 做任何保证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LFENCE&lt;/code> 则保证该指令之前的所有 Load 操作不会“跨过”该指令，也同样不对 Store 做任何保证；注意这里带了一条尾注，指明 &lt;code>LFENCE&lt;/code> 不仅仅能同步数据，也能同步指令，在其他指令没有执行完前不会执行 &lt;code>LFENCE&lt;/code>，所以在一个&lt;a href="https://www.zhihu.com/question/29465982/answer/44465936">知乎回答&lt;/a>说明了这个特性被用在了内核 &lt;code>RDTSC&lt;/code> 之前，以获取更加精确的时钟。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MFENCE&lt;/code> 则会保证之前所有的 Store/Load 操作都不会“跨过”该指令；注意在汇编的世界中（我认为）单条指令永远不等价于多条指令的“和”，例如这里的 &lt;code>MFENCE != SFENCE + LFENCE&lt;/code>，原因就是“原子性”，如果用 &lt;code>SFENCE + LFENCE&lt;/code> 替代 &lt;code>MFENCE&lt;/code> 的话，有个比较大的问题就是两条指令中间有可能存在一定的“空窗期”：在两条指令中间，虽然 &lt;code>SFENCE&lt;/code> 保证了当前核心之前的所有 Store 指令都完成了，但是现在空窗期间（执行 &lt;code>LFENCE&lt;/code> 前）我们已经不能再保证 Store-Store 序了，因为其他 CPU 可能会执行任何的读写操作。这一点在 &lt;a href="https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/#storeload">Preshing 的文章&lt;/a>中也提及到了：&lt;/p>
&lt;blockquote>
&lt;p>However, those two barrier types are insufficient. Remember, the push operation may be delayed for an arbitrary number of instructions, and the pull operation might not pull from the head revision.&lt;/p>
&lt;/blockquote>
&lt;p>所以在汇编上我们必须要有一个 single instrument 来保证 atomicity，这跟 &lt;code>inc&lt;/code>、&lt;code>xchg&lt;/code> 等“混合”指令的作用是类似的，虽然它们都能拆分成多个指令，但是为了保证原子性必须要提供（就算非常精简以及 weakly-ordered 的 RISC-V 架构依然存在着 &lt;code>xchg&lt;/code> 这样的指令，来保证原子性）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>总而言之，通常操作下我们并不需要关心 x86 的内存屏障，因为它已经“足够的强”了，但是面对其他情况下依然需要屏障。&lt;/p>
&lt;p>P.S. 比较有意思的一段话：&lt;/p>
&lt;blockquote>
&lt;p>Intel does not guarantee that future processors will support this model.&lt;/p>
&lt;/blockquote>
&lt;p>看来 Intel 也非常想废弃掉 TSO 啊（笑）。&lt;/p>
&lt;h2 id="sequentially-consistent">Sequentially Consistent&lt;/h2>
&lt;p>内存屏障的其中一个作用，就是将 TSO 内存序变为更强的 SC 内存序，具体做法参考 &lt;a href="https://stackoverflow.com/a/27635527">StackOverflow 的答案&lt;/a>，里面列出了四种做法：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>&lt;code>LOAD&lt;/code> (without fence) and &lt;code>STORE&lt;/code> + &lt;code>MFENCE&lt;/code>&lt;/li>
&lt;li>&lt;code>LOAD&lt;/code> (without fence) and &lt;code>LOCK XCHG&lt;/code>&lt;/li>
&lt;li>&lt;code>MFENCE&lt;/code> + &lt;code>LOAD&lt;/code> and &lt;code>STORE&lt;/code> (without fence)&lt;/li>
&lt;li>&lt;code>LOCK XADD&lt;/code> ( 0 ) and &lt;code>STORE&lt;/code> (without fence)&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>并且指出 GCC 使用的就是方法 1，也就是 &lt;code>STORE + MFENCE&lt;/code> 就能将 TSO 转变为 SC。这个比较好理解，因为 &lt;code>MFENCE&lt;/code> 保证了指令之前的&lt;strong>所有读写&lt;/strong>操作都对其他核心可见，那么如果我们每次写的时候都执行一次 &lt;code>MFENCE&lt;/code>，就意味着每次写完就去强制读写可见，那么后面的读就必定只会读到最新的指。另外因为 SC 要保证 StoreLoad，所以就必须要 &lt;code>MFENCE&lt;/code>（？）。&lt;/p>
&lt;h2 id="non-temporal">Non-Temporal&lt;/h2>
&lt;p>上面提到了对于 NT（Non-Temporal）操作，我们是不能保证 Store-Store 序的，也就是说一个 NT 指令后立刻接上另外的 Store 指令，那么最终的结果是无法确定的，这也是 x86 中 relaxed-order 的体现。所以对于所有的 NT 指令，都建议带上 &lt;code>SFENCE&lt;/code> 内存屏障。&lt;/p>
&lt;blockquote>
&lt;p>Non-Temporal SSE instructions (MOVNTI, MOVNTQ, etc.), don&amp;rsquo;t follow the normal cache-coherency rules. Therefore non-temporal stores must be followed by an SFENCE instruction in order for their results to be seen by other processors in a timely fashion.&lt;/p>
&lt;p>When data is produced and not (immediately) consumed again, the fact that memory store operations read a full cache line first and then modify the cached data is detrimental to performance. This operation pushes data out of the caches which might be needed again in favor of data which will not be used soon. This is especially true for large data structures, like matrices, which are filled and then used later. Before the last element of the matrix is filled the sheer size evicts the first elements, making caching of the writes ineffective.&lt;/p>
&lt;p>For this and similar situations, processors provide support for non-temporal write operations. Non-temporal in this context means the data will not be reused soon, so there is no reason to cache it. These non-temporal write operations do not read a cache line and then modify it; instead, the new content is directly written to memory.&lt;/p>
&lt;p>Source: &lt;a href="http://lwn.net/Articles/255364/">http://lwn.net/Articles/255364/&lt;/a> &lt;a href="https://stackoverflow.com/a/37092">https://stackoverflow.com/a/37092&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>NT 与否其实是跟 cache 有很大关系，这里的解释说是 Non-Temporal 的所有操作都不走 cache（所以才叫“非临时”？）。还是翻一下 SDM 吧，首先直接找到 &lt;code>MOVNTDQA&lt;/code> 的指令介绍吧，在卷 2 4.3 中，摘录关于 Non-Temporal 的部分：&lt;/p>
&lt;blockquote>
&lt;p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when reading the data from memory. Using this protocol, the processor does not read the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being read can override the non-temporal hint, if the memory address specified for the non-temporal read is not a WC memory region. Information on non-temporal reads and writes can be found in “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the Intel® 64 and IA-32 Architecture Software Developer’s Manual, Volume 3A.&lt;/p>
&lt;p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with a MFENCE instruction should be used in conjunction with MOVNTDQA instructions if multiple processors might use different memory types for the referenced memory locations or to synchronize reads of a processor with writes by other agents in the system. A processor’s implementation of the streaming load hint does not override the effective memory type, but the implementation of the hint is processor dependent. For example, a processor implementation may choose to ignore the hint and process the instruction as a normal MOVDQA for any memory type. Alternatively, another implementation may optimize cache reads generated by MOVNTDQA on WB memory type to reduce cache evictions.&lt;/p>
&lt;/blockquote>
&lt;p>这里简要地说明了这个指令的一些细节，例如它的作用就是将内存中的数据读到寄存器中，但是不经过缓存层（也不触发任何的 fetch），第二段则指出了该指令工作在 weakly-ordered 的内存序下，因此需要借助前文说的内存屏障来保证可见性（以及顺序性）。顺便这里也指路到了 SDM 卷 1 10.4.6.2（跟原文的卷号对不上，标错了？）：&lt;/p>
&lt;blockquote>
&lt;p>Data referenced by a program can be temporal (data will be used again) or non-temporal (data will be referenced once and not reused in the immediate future). For example, program code is generally temporal, whereas, multimedia data, such as the display list in a 3-D graphics application, is often non-temporal. &lt;strong>To make efficient use of the processor’s caches, it is generally desirable to cache temporal data and not cache non-temporal data.&lt;/strong> Overloading the processor’s caches with non-temporal data is sometimes referred to as “polluting the caches.” The SSE and SSE2 cacheability control instructions enable a program to write non-temporal data to memory in a manner that minimizes pollution of caches.&lt;/p>
&lt;/blockquote>
&lt;p>也就是说 NT 宽泛来说（概念性）指的就是不会立刻被使用到的数据，也因此出于性能考虑也就不再进行缓存，将缓存让给 temporal data。因此从实现角度来说 NT 就是不经过缓存的数据，考据终了。&lt;/p>
&lt;p>P.S. 在 SDM 卷 3 11.3 中能找到所有的 Memory Types 和相关解释。不贴原文了，整理（粗略地理解）了一下：&lt;/p>
&lt;ul>
&lt;li>Write Combining (WC)：对于一些无法被缓存（cache）的项目，会存在一个专门的 buffer（write combining buffer）来收集并“聚合”（combine）这些读写操作并推迟写入，以此来减少内存（或者 I/O）的读写次数；一些 serializing 指令（如上面提到的 &lt;code>SFENCE&lt;/code>、&lt;code>MFENCE&lt;/code> 以及 &lt;code>CPUID&lt;/code> 等）会强行落地并清空 WC Cache。更多关于 WC Buffer 可以参考 &lt;a href="https://stackoverflow.com/a/49961612">StackOverflow 上的答案&lt;/a>，比较复杂，我也没仔细地去看了 orz。&lt;/li>
&lt;li>Write-through (WT)：所有的 Load/Store 都走 cache，但是每次在往 cache 中写入（Store）时都会直接同步到内存中；读取（Load）则依然会从 cache 中读取。因此 WT 比较适合写不敏感，但是要求与内存保持同步的一些场景（I/O？）。&lt;/li>
&lt;li>Write-back (WB)：所有的 Load/Store 都走 cache，数据会保持在 cache 中直到缓存策略决定该何时写回到内存。这就是我们最常用（也是性能最好的）一种 cache 模式。但是对于 I/O 等需要访问内存的外设（device）肯定就需要考虑一致性的问题了，同时也需要考虑缓存一致性的问题（cache coherency）。&lt;/li>
&lt;li>Write protected (WP)：只对 Load 操作走 cache，所有的 Store 的操作都会让缓存失效。&lt;/li>
&lt;/ul>
&lt;p>P.P.S. 有一个 &lt;code>PREFETCH&lt;/code> 指令可以显式地将部分内存载入到缓存中，这也是在内核代码里看到很多 prefetch 的原理。具体可以看指令说明。&lt;/p>
&lt;h2 id="follymemcpys">folly/memcpy.S&lt;/h2>
&lt;p>这里我的兴趣点在于 &lt;code>.L_NON_TEMPORAL_LOOP&lt;/code> 这个 label 上，首先可以找到哪里会跳转到这里来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#a6e22e">This&lt;/span> threshold is half of L1 cache on a Skylake machine, which means that
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#a6e22e">potentially&lt;/span> all of L1 will be populated by this copy once it is executed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>&lt;span style="color:#a6e22e">dst&lt;/span> and src are cached for temporal copies).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#a6e22e">define&lt;/span> NON_TEMPORAL_STORE_THRESHOLD &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">32768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">cmp&lt;/span> NON_TEMPORAL_STORE_THRESHOLD, &lt;span style="color:#f92672">%&lt;/span>rdx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">jae&lt;/span> .L_NON_TEMPORAL_LOOP
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说当我们 &lt;code>memcpy&lt;/code> 的大小超过了 L1 缓存（folly 取了 Skylake 作为基准）后，就不再借助缓存去拷贝了，而是直接利用上述的 &lt;code>MOVNTx&lt;/code> 系列的 NT 指令绕过缓存，实现比较高性能的拷贝：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>.L_NON_TEMPORAL_LOOP:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">testb&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">31&lt;/span>, &lt;span style="color:#f92672">%&lt;/span>sil
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">jne&lt;/span> .L_ALIGNED_DST_LOOP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#a6e22e">This&lt;/span> is prefetching the source data unlike ALIGNED_DST_LOOP which
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#a6e22e">prefetches&lt;/span> the destination data. This choice is again informed by
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#a6e22e">benchmarks.&lt;/span> With a non&lt;span style="color:#f92672">-&lt;/span>temporal store the entirety of the cache line
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#a6e22e">is&lt;/span> being written so the previous data can be discarded without being
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#a6e22e">fetched.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prefetchnta&lt;/span> &lt;span style="color:#ae81ff">128&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prefetchnta&lt;/span> &lt;span style="color:#ae81ff">196&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vmovntdqa&lt;/span> (&lt;span style="color:#f92672">%&lt;/span>rsi), &lt;span style="color:#f92672">%&lt;/span>ymm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vmovntdqa&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsi), &lt;span style="color:#f92672">%&lt;/span>ymm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vmovntdqa&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsi), &lt;span style="color:#f92672">%&lt;/span>ymm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vmovntdqa&lt;/span> &lt;span style="color:#ae81ff">96&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsi), &lt;span style="color:#f92672">%&lt;/span>ymm3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">add&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">128&lt;/span>, &lt;span style="color:#f92672">%&lt;/span>rsi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vmovntdq&lt;/span> &lt;span style="color:#f92672">%&lt;/span>ymm0, (&lt;span style="color:#f92672">%&lt;/span>rdi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vmovntdq&lt;/span> &lt;span style="color:#f92672">%&lt;/span>ymm1, &lt;span style="color:#ae81ff">32&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rdi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vmovntdq&lt;/span> &lt;span style="color:#f92672">%&lt;/span>ymm2, &lt;span style="color:#ae81ff">64&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rdi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vmovntdq&lt;/span> &lt;span style="color:#f92672">%&lt;/span>ymm3, &lt;span style="color:#ae81ff">96&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rdi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">add&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">128&lt;/span>, &lt;span style="color:#f92672">%&lt;/span>rdi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cmp&lt;/span> &lt;span style="color:#f92672">%&lt;/span>r8, &lt;span style="color:#f92672">%&lt;/span>rsi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">jb&lt;/span> .L_NON_TEMPORAL_LOOP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sfence&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">jmp&lt;/span> .L_ALIGNED_DST_LOOP_END
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 folly 借助 &lt;code>movntdqa&lt;/code> 指令将数据读入到 AVX 寄存器 &lt;code>ymmX&lt;/code> 中，再使用 &lt;code>movntdq&lt;/code> 将寄存器的值写回到内存，并循环。最后，注意到这里还有个 &lt;code>sfence&lt;/code> 指令，保证在拷贝完后数据对其他核心可见（但是拷贝途中无法保证，所以可能需要调用着确保不会出现 data race），符合 SDM 上的定义。&lt;/p>
&lt;p>到此，基本上我们也理解了 x86 的 TSO 内存序（比 SC 弱的地方在于只能保证同一个地址的 Store-Load，但是可以通过 &lt;code>MFENCE&lt;/code> 指令做到所有地址的 Store-Load 以实现 SC）、x86 的内存屏障的作用（通常程序中因为 TSO 的存在没有什么作用，但是对于如 NT 系列的特殊指令需要 weakly-ordered memory，就必须使用内存屏障了；不过为了程序的 portable 性，还是尽量地加上内存屏障操作，也能加深理解）。现在，我们再来尝试理解（困扰我多年的.jpg）C++ &lt;code>std::memory_order&lt;/code> 了。&lt;/p>
&lt;h2 id="cache">Cache&lt;/h2>
&lt;p>关于 Memory Order，偶尔还是会提到缓存，因为像 Intel x86 等主流实现来说，基本都会带有缓存。那么我们对内存进行操作的时候就会存在一个中间的 cache 状态，这可能会导致内存序出现一些小小的差异（例如如果有一个简单的 cache，我们往同一个内存地址多次写入数据，那么实际就只是一直在往 cache 中写入数据，没有&lt;em>及时地&lt;/em>写回到内存中去，其他 CPU 就无法观测，也就无法保证 Store-Load 等内存序了）。&lt;/p>
&lt;p>这个问题就交由缓存一致性算法来解决，最终实现的效果就是在 x86 下无论我们怎么操作 cache 和内存，只要地址相同，就能保证其他 CPU 始终能观测到最新值，从而保证 Store-Load 序正确（上面的例子也就不会出现无法观测的问题）。而对于其他架构而言，应该也需要实现类似的效果，起码是需要有处理 atomic 的能力，即能让别的 CPU 观测到对内存操作的变化。&lt;/p>
&lt;p>对于 x86 而言，常用的缓存一致性协议是 MESI，这个协议比较重要的就是“嗅探机制”（snoop），也是通过 snoop 通过总线来得知其他 CPU 的操作；具体可以查看&lt;a href="https://en.wikipedia.org/wiki/MESI_protocol">维基百科 MESI&lt;/a> 的页面，这部分我暂时还没深入地去了解，大概只知道这些了（逃。&lt;/p>
&lt;h2 id="编译器的指令重排">编译器的指令重排&lt;/h2>
&lt;p>有时候在大量存在变量的读写时，编译器会选择性地进行指令重排（例如你能在 GDB 中发现很多“诡异”的跳转，常常执行到一半的时候跳回到开头执行变量的初始化等），这就是区别于 CPU 指令重排的编译器指令重排。编译器重排基本都是在编译期做的，有两种方式可以抑制：&lt;/p>
&lt;ol>
&lt;li>变量使用 &lt;code>volatile&lt;/code> 关键字，针对的是该变量；&lt;/li>
&lt;li>使用 &lt;code>asm volatile(&amp;quot;&amp;quot; ::: &amp;quot;memory&amp;quot;)&lt;/code>，针对的是该语句上下的重排，跟 CPU 的内存屏障很像，就是避免语句之前的读写操作重新排序到该语句之后。另外语句起作用的地方是 &lt;code>&amp;quot;memory&amp;quot;&lt;/code>，所以第一个参数无论是任何汇编指令都会有抑制编译器重排的效果。&lt;/li>
&lt;/ol>
&lt;p>大概也就是这些了，文章重点依然在 x86 上，暂时不讨论编译器了（其实是不会 QAQ）。&lt;/p>
&lt;p>后续会写一篇 C/C++ 的 Memory Order，来对“真实世界”中的内存模型（希望能）有一个更稍微透彻的理解&lt;del>以及咕咕咕&lt;/del>。&lt;/p></description></item><item><title>关于</title><link>https://error.iorw.io/about/</link><pubDate>Fri, 09 Dec 2022 22:54:54 +0800</pubDate><guid>https://error.iorw.io/about/</guid><description>&lt;h2 id="me-myself-and-i">Me, Myself, and I&lt;/h2>
&lt;ul>
&lt;li>不太起眼的一只鶸&lt;/li>
&lt;li>装懂以及强答流作者&lt;/li>
&lt;li>失业人群&lt;/li>
&lt;/ul>
&lt;h2 id="blog">b:log().&lt;/h2>
&lt;ul>
&lt;li>只是文章的搬运工&lt;/li>
&lt;li>多数情况下都是在胡说&lt;/li>
&lt;li>其他情况下是在乱说&lt;/li>
&lt;/ul>
&lt;h2 id="friends">Friends&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.zzfly.net">烟花易冷&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://virgilg72.github.io/">VirgilG72&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.yukicat.net/">雪猫社&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>乱谈 Monad</title><link>https://error.iorw.io/2022/12-08-babble-monad/</link><pubDate>Thu, 08 Dec 2022 20:46:25 +0800</pubDate><guid>https://error.iorw.io/2022/12-08-babble-monad/</guid><description>&lt;h2 id="preface">Preface&lt;/h2>
&lt;p>这几天按着我半吊子的 haskell 水平稍微研究了一下 monad，还是有点不是很理解，只能浅浅地谈一谈我自己的想法，错误和纰漏难以避免，所谓乱谈是也。&lt;/p>
&lt;h2 id="the-moand">The Moand&lt;/h2>
&lt;p>这部分尽量会详细地阐述一下&lt;a href="https://www.zhihu.com/question/19635359/answer/172074046">刘月半大神的这篇文章&lt;/a>，适当的改动了一些例子，首先从 &lt;code>Maybe&lt;/code> 的构造函数开始，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> a &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>a&lt;/code> 是一个类型，我们可以“实例化”一个 &lt;code>Maybe Int&lt;/code> 类型出来等等，并且存在两个“构造器”，&lt;code>Just&lt;/code> 和 &lt;code>Nothing&lt;/code>。例如我们可以构造一个 &lt;code>safeDiv&lt;/code> 函数，这个函数作用是保证在遇到除零错误时不会让程序 crash，而是返回一个 &lt;code>Maybe Int&lt;/code> 类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">safeDiv&lt;/span> &lt;span style="color:#f92672">::&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">safeDiv&lt;/span> &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">safeDiv&lt;/span> x y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> (x `div` y) &lt;span style="color:#75715e">-- 除法运算符 / 不能作用在 Int 上&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们希望一个比较复杂的除法运算中，都能保证除零安全的话，我们可能会写出下面这样的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 安全地计算 a/b/c/d/e&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> safeDiv a b &lt;span style="color:#66d9ef">of&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Just&lt;/span> x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> safeDiv x c &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#75715e">-- 如果 b != 0，能够继续进行除法，尝试计算 (a/b)/c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Just&lt;/span> y &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> safeDiv y d &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#75715e">-- 如果 c != 0，继续尝试计算 (a/b/c)/d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Just&lt;/span> z &lt;span style="color:#f92672">-&amp;gt;&lt;/span> safeDiv z e &lt;span style="color:#75715e">-- 如果 d != 0，继续尝试计算 (a/b/c/d)/e&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到代码非常的啰嗦，而且看着很难受（对应过程式语言就是一层又一层的 if 嵌套），有没有办法能优化呢？实际上上面的例子中，我们可以从几个 &lt;code>case&lt;/code> 中提取出一些公共特征（伪代码，&lt;code>{Int}&lt;/code> 表示此处的变量类型为 &lt;code>Int&lt;/code>）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 将 safeDiv x c 使用 \x -&amp;gt; safeDiv x c 替换，即可得到最简洁的 Int -&amp;gt; Maybe Int 函数；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 因为被 lambda 捕获的量基本都能被视作常量（？）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> {&lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>} &lt;span style="color:#66d9ef">of&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Just&lt;/span> x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {&lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>} x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>给上面的类型附上名字和类型，就成了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&amp;#39;&lt;/span> &lt;span style="color:#f92672">::&lt;/span> (&lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&amp;#39;&lt;/span> f m &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> m &lt;span style="color:#66d9ef">of&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Just&lt;/span> x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> f x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到这里我们就得到了一个 &lt;code>Maybe&lt;/code> 的所谓 functor（函子），&lt;/p>
&lt;blockquote>
&lt;p>Maybe 之所以是函子，是因为它可以通过 fmap（functor map）把所有的函数拎到「Maybe 空间」里。&lt;/p>
&lt;/blockquote>
&lt;p>有了函子之后，我们尝试把这个抽象应用到我们的例子上去看看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> safeDiv a b &lt;span style="color:#75715e">-- 第一层 a/b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">=&lt;/span> fmap&amp;#39; (&lt;span style="color:#a6e22e">\&lt;/span>v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> safeDiv v c) x &lt;span style="color:#75715e">-- 第二层 (a/b)/c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> z &lt;span style="color:#f92672">=&lt;/span> fmap&amp;#39; (&lt;span style="color:#a6e22e">\&lt;/span>v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> safeDiv v d) y &lt;span style="color:#75715e">-- 第三层 (a/b/c)/d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmap&amp;#39; (&lt;span style="color:#a6e22e">\&lt;/span>v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> safeDiv v e) z &lt;span style="color:#75715e">-- 第四层 (a/b/c/d)/e&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>抛开性能不谈（雾），这种写法看起来已经舒服很多了，但是感觉还是“存在进步空间”的样子。也的确，haskell 给我们提供了一个 &lt;code>&amp;gt;&amp;gt;=&lt;/code> 运算符，可以让我们来实现 &lt;code>fmap&lt;/code>，并且再次优化上面的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 这是一个中缀运算符，这个例子中 (&amp;gt;&amp;gt;=) m f 等价于 m &amp;gt;&amp;gt;= f；定义与 fmap&amp;#39; 完全一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span>) &lt;span style="color:#f92672">::&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (&lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span>) m f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> m &lt;span style="color:#66d9ef">of&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Just&lt;/span> x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> f x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- the optimzed version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">safeDiv&lt;/span> a b &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> (&lt;span style="color:#a6e22e">\&lt;/span>v &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> safeDiv v c &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> (&lt;span style="color:#a6e22e">\&lt;/span>w &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> safeDiv w d &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> (&lt;span style="color:#a6e22e">\&lt;/span>x &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> safeDiv x e)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好像，有点反向优化了？没事，haskell 为这个模式设计了 &lt;code>do&lt;/code> 语法糖：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">&amp;lt;-&lt;/span> safeDiv a b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">&amp;lt;-&lt;/span> safeDiv x c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> z &lt;span style="color:#f92672">&amp;lt;-&lt;/span> safeDiv y d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> safeDiv z e
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>简洁，好看，elegant！这就是“所谓的” monad 了！当然，因为标准库里&lt;a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Maybe.html">已经提供&lt;/a>了 &lt;code>instance Monad Maybe&lt;/code> 了，所以最后的代码中，我们不需要再定义任何其他函数了，只需要保留 &lt;code>safeDiv&lt;/code> 就可以了。当然我们也能自行实现各种各样的 functor，有点像是 OOP 的接口一样（笑）。&lt;/p>
&lt;h2 id="functor-and-monad">Functor and Monad&lt;/h2>
&lt;p>上面的例子中，我们的 &lt;code>fmap'&lt;/code> 是自己定义的，而官方针对 &lt;a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/src/GHC.Base.html">&lt;code>Maybe&lt;/code> 实现的 &lt;code>fmap&lt;/code>&lt;/a> 是不太一样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- | @since 2.01&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">instance&lt;/span> &lt;span style="color:#66d9ef">Functor&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmap &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmap f (&lt;span style="color:#66d9ef">Just&lt;/span> a) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> (f a) &lt;span style="color:#75715e">-- notice here!&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们的例子中模式匹配项是 &lt;code>Just x -&amp;gt; f x&lt;/code>，但是官方的却是 &lt;code>Just a -&amp;gt; Just (f a)&lt;/code>，后者其实才是标准格式；&lt;code>safeDiv&lt;/code> 这个例子不同是因为我们完全是根据函数类型来“特化”的一个：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- safeDiv version of fmap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&lt;/span> &lt;span style="color:#f92672">::&lt;/span> (&lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- haskell fmap, f is functor, eq to `Maybe`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&lt;/span> &lt;span style="color:#f92672">::&lt;/span> (a &lt;span style="color:#f92672">-&amp;gt;&lt;/span> b) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> f a &lt;span style="color:#f92672">-&amp;gt;&lt;/span> f b
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到差异在第一个参数类型上。这里提这个区别是因为这里要开始区分 functor 和 monad 了。前文的例子中可能大家会觉得 monad 跟 functor 是一回事，实际上是存在差异的。Haskell 定义了 &lt;a href="https://wiki.haskell.org/Functor-Applicative-Monad_Proposal">Functor-Applicative-Monad&lt;/a> 结构，简而言之就是 applicative 必定是 functor，monad 必定是 applicative，三者有继承关系，所以 functor 其实是性质是比较弱的。&lt;/p>
&lt;p>这部分主要会根据哔站&lt;a href="https://www.bilibili.com/video/BV1qh411q7cS">鹤翔万里的视频&lt;/a>进行一定的细致阐述，也会对前文刘月半大神的文章进行再补充。先从 functor 开始吧，它的作用看上面函数定义就能略知一二了，给定一个一般的函数，让它去处理“装箱”后的类型，并且返回一个同样被装箱了的类型，看 haskell 的 &lt;code>Maybe&lt;/code> 实现就知道了，这里贴出来视频的几个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- instance Functor Maybe&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&lt;/span> (&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>) (&lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&lt;/span> (&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- instance Functor []&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&lt;/span> (&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>) [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然 functor 根据定义，它的局限性就在于只能处理值，对于函数，它只会返回一个装箱后的函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&lt;/span> (&lt;span style="color:#f92672">+&lt;/span>) (&lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> (&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且我们无法继续往下进行了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&lt;/span> (&lt;span style="color:#66d9ef">Just&lt;/span> (&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>)) (&lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">🤯&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时就需要引入 applicative 来处理了，直接看官方定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- | @since 2.01&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">instance&lt;/span> &lt;span style="color:#66d9ef">Applicative&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pure &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Just&lt;/span> f &lt;span style="color:#f92672">&amp;lt;*&amp;gt;&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> fmap f m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">&amp;lt;*&amp;gt;&lt;/span> _m &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> liftA2 f (&lt;span style="color:#66d9ef">Just&lt;/span> x) (&lt;span style="color:#66d9ef">Just&lt;/span> y) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> (f x y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> liftA2 &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Just&lt;/span> _m1 &lt;span style="color:#f92672">*&amp;gt;&lt;/span> m2 &lt;span style="color:#f92672">=&lt;/span> m2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span> _m2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主要关注 &lt;code>&amp;lt;*&amp;gt;&lt;/code> 这个函数（读作 apply），可以看到 applicative 将 &lt;code>Just (+3)&lt;/code> 里面的 &lt;code>(+3)&lt;/code> 函数给取出来了，然后通过 &lt;code>fmap&lt;/code> 应用函数，这样得到的结果依然是个 &lt;code>Maybe&lt;/code> 类型，it just works。&lt;/p>
&lt;p>同样，贴上视频中的几个例子当作 memo：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- instance Applicative Maybe&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">Just&lt;/span> (&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">&amp;lt;*&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- instance Applicative []&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[(&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>), (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>)] &lt;span style="color:#f92672">&amp;lt;*&amp;gt;&lt;/span> [&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们把前文例子中 &lt;code>safeDiv&lt;/code> 里的 &lt;code>fmap'&lt;/code> 删去，那么下面这个函数就会开始出类型错误：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- without customized fmap function&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> safeDiv a b &lt;span style="color:#75715e">-- 第一层 a/b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">=&lt;/span> fmap (&lt;span style="color:#a6e22e">\&lt;/span>v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> safeDiv v c) x &lt;span style="color:#75715e">-- 第二层 (a/b)/c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> z &lt;span style="color:#f92672">=&lt;/span> fmap (&lt;span style="color:#a6e22e">\&lt;/span>v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> safeDiv v d) y &lt;span style="color:#75715e">-- 第三层 (a/b/c)/d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmap (&lt;span style="color:#a6e22e">\&lt;/span>v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> safeDiv v e) z &lt;span style="color:#75715e">-- 第四层 (a/b/c/d)/e&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原因前文说了，&lt;code>fmap&lt;/code> 其实返回的是 &lt;code>Just (f a)&lt;/code>，也就是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmap&lt;/span> (&lt;span style="color:#a6e22e">\&lt;/span>v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> safeDiv v &lt;span style="color:#ae81ff">1&lt;/span>) (&lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> (&lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这就有点难受了，不是我们预期想要的 &lt;code>Just 10&lt;/code>。这种情况下就需要使用 monad 了，也就是上面定义中 &lt;code>&amp;gt;&amp;gt;=&lt;/code>（读作 bind）来进行处理了，也是直接看官方代码吧：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- | @since 2.01&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">instance&lt;/span> &lt;span style="color:#66d9ef">Monad&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">Just&lt;/span> x) &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> k x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对比官方 &lt;code>fmap&lt;/code> 就能看到，monad 的 instance 中不再是 &lt;code>Just (k x)&lt;/code>，而是简介、明了的 &lt;code>k x&lt;/code>，neat。这也是跟我们在 &lt;code>safeDiv&lt;/code> 中实现的 &lt;code>&amp;gt;&amp;gt;=&lt;/code> 版本完全等价，所以它就是一个 monad。&lt;/p>
&lt;p>依然，贴上一些视频中的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">\&lt;/span>x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> (x&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Just&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>个人理解，无论是 functor、applicative 还是 monad，它们本质上都是为了更好地处理“被装箱的类型”。而 haskell 比较推崇这种盒子模式，很多类型像 &lt;code>Maybe a&lt;/code>、&lt;code>IO a&lt;/code> 这种，都实现了 monad 的 bind 运算符。&lt;/p>
&lt;p>比如 Haskell 里常用的数组展开，其实也是借助 functor 来完成的，来自&lt;a href="https://zhuanlan.zhihu.com/p/39734882">评论区的 Narc 大神&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- original&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ x &lt;span style="color:#f92672">+&lt;/span> y &lt;span style="color:#f92672">|&lt;/span> x &lt;span style="color:#f92672">&amp;lt;-&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>], y &lt;span style="color:#f92672">&amp;lt;-&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>x]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- desuger&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">\&lt;/span>x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>x] &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">\&lt;/span>y &lt;span style="color:#f92672">-&amp;gt;&lt;/span> return (x &lt;span style="color:#f92672">+&lt;/span> y)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外 JavaScript 的 &lt;code>Promise&lt;/code> 也是跟 monad 有点“异曲同工”之妙的，毕竟 lazy eval 能看作是异步（。&lt;/p>
&lt;h2 id="myth">Myth&lt;/h2>
&lt;p>我个人依然有一些迷思，可能需要系统地学习下范畴论才能解惑了。&lt;/p>
&lt;ol>
&lt;li>都说 monad 能隔离副作用，但是我看下，感觉跟闭包差不多？将所有状态装箱到一个闭包中，当然外部无法修改，&lt;a href="https://stackoverflow.com/a/79077">Stack Overflow 上也有讨论&lt;/a>，说区别在于“A monad is (roughly) more like a context in which functions can be chained together sequentially, and controls how data is passed from one function to the next.”&lt;/li>
&lt;li>对用法依然不是很清晰，暂时的想法是，monad 就是用来处理“盒子”的，side effect 可以装进盒子中，error handling 也可以装进去，等等；并且 monad 可以“传递”（不同于 closure 只能捕获函数内的，monad 可以捕获整个链式调用上的结果)，加上 &lt;code>return&lt;/code> 函数的辅助，容易实现 chain call，并且 chain 上的函数都共享整个 context？&lt;/li>
&lt;li>一个自函子范畴上的幺半群。。嗯，还是不太懂😂&lt;/li>
&lt;/ol>
&lt;p>还有，原知乎帖子里讲述了一个 &lt;code>join&lt;/code> 操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> safeDiv a b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">=&lt;/span> fmap (safeDiv c) x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> z &lt;span style="color:#f92672">=&lt;/span> (fmap &lt;span style="color:#f92672">.&lt;/span> fmap) (safeDiv d) y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in&lt;/span> (fmap &lt;span style="color:#f92672">.&lt;/span> fmap &lt;span style="color:#f92672">.&lt;/span> fmap) (safeDiv e) z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">join&lt;/span> &lt;span style="color:#f92672">::&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> (&lt;span style="color:#66d9ef">Maybe&lt;/span> a) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> join (&lt;span style="color:#66d9ef">Just&lt;/span> x) &lt;span style="color:#f92672">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> join &lt;span style="color:#66d9ef">Nothing&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span>) &lt;span style="color:#f92672">::&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> a &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (a &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> b) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">Maybe&lt;/span> b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span>) mbx f &lt;span style="color:#f92672">=&lt;/span> join (fmap f mbx)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这一部分我暂时还不是很懂，答主给的例子中那一串 &lt;code>fmap&lt;/code> 我暂时还是没能推导出类型出来（不太熟悉 &lt;code>.&lt;/code> 操作符，是 haskell 超高校级的新手了）。To be continued。&lt;/p>
&lt;p>其实自己还是有挺多地方不懂的，不过 haskell 可能暂时不会再学习了，目前对 erlang 更有兴趣一些，学一门语言等于学完了并发范式，不香吗不香吗（其实主要是数学太渣了，看了一小会范畴论就已经开始歇菜了🤧）。&lt;/p></description></item></channel></rss>