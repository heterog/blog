<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Lindsay"><meta name=description content="A static blog builded by hugo"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://cdn.simplecss.org/simple.min.css><title>乱谈 Monad</title></head><body><header><nav><a href=https://error.iorw.io/>[->+&lt;]</a>
<a href=https://error.iorw.io/about>About</a></nav><h1>乱谈 Monad</h1><p>2022-12-08 12:46 +0000</p></header><main><h2 id=preface>Preface</h2><p>这几天按着我半吊子的 haskell 水平稍微研究了一下 monad，还是有点不是很理解，只能浅浅地谈一谈我自己的想法，错误和纰漏难以避免，所谓乱谈是也。</p><h2 id=the-moand>The Moand</h2><p>这部分尽量会详细地阐述一下<a href=https://www.zhihu.com/question/19635359/answer/172074046>刘月半大神的这篇文章</a>，适当的改动了一些例子，首先从 <code>Maybe</code> 的构造函数开始，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Maybe</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> a <span style=color:#f92672>|</span> <span style=color:#66d9ef>Nothing</span>
</span></span></code></pre></div><p>其中 <code>a</code> 是一个类型，我们可以“实例化”一个 <code>Maybe Int</code> 类型出来等等，并且存在两个“构造器”，<code>Just</code> 和 <code>Nothing</code>。例如我们可以构造一个 <code>safeDiv</code> 函数，这个函数作用是保证在遇到除零错误时不会让程序 crash，而是返回一个 <code>Maybe Int</code> 类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>safeDiv</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>safeDiv</span> <span style=color:#66d9ef>_</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>safeDiv</span> x y <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> (x `div` y)	<span style=color:#75715e>-- 除法运算符 / 不能作用在 Int 上</span>
</span></span></code></pre></div><p>如果我们希望一个比较复杂的除法运算中，都能保证除零安全的话，我们可能会写出下面这样的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- 安全地计算 a/b/c/d/e</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> safeDiv a b <span style=color:#66d9ef>of</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>Just</span> x  <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>case</span> safeDiv x c <span style=color:#66d9ef>of</span>	<span style=color:#75715e>-- 如果 b != 0，能够继续进行除法，尝试计算 (a/b)/c</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Just</span> y  <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>case</span> safeDiv y d <span style=color:#66d9ef>of</span>	<span style=color:#75715e>-- 如果 c != 0，继续尝试计算 (a/b/c)/d</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>Just</span> z  <span style=color:#f92672>-&gt;</span> safeDiv z e		<span style=color:#75715e>-- 如果 d != 0，继续尝试计算 (a/b/c/d)/e</span>
</span></span></code></pre></div><p>可以看到代码非常的啰嗦，而且看着很难受（对应过程式语言就是一层又一层的 if 嵌套），有没有办法能优化呢？实际上上面的例子中，我们可以从几个 <code>case</code> 中提取出一些公共特征（伪代码，<code>{Int}</code> 表示此处的变量类型为 <code>Int</code>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- 将 safeDiv x c 使用 \x -&gt; safeDiv x c 替换，即可得到最简洁的 Int -&gt; Maybe Int 函数；</span>
</span></span><span style=display:flex><span><span style=color:#75715e>--   因为被 lambda 捕获的量基本都能被视作常量（？）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> {<span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>} <span style=color:#66d9ef>of</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>Just</span> x <span style=color:#f92672>-&gt;</span> {<span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>} x
</span></span></code></pre></div><p>给上面的类型附上名字和类型，就成了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>fmap&#39;</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmap&#39;</span> f m <span style=color:#f92672>=</span> <span style=color:#66d9ef>case</span> m <span style=color:#66d9ef>of</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>Just</span> x <span style=color:#f92672>-&gt;</span> f x
</span></span></code></pre></div><p>到这里我们就得到了一个 <code>Maybe</code> 的所谓 functor（函子），</p><blockquote><p>Maybe 之所以是函子，是因为它可以通过 fmap（functor map）把所有的函数拎到「Maybe 空间」里。</p></blockquote><p>有了函子之后，我们尝试把这个抽象应用到我们的例子上去看看：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> safeDiv a b			<span style=color:#75715e>-- 第一层 a/b</span>
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> fmap&#39; (<span style=color:#a6e22e>\</span>v <span style=color:#f92672>-&gt;</span> safeDiv v c) x	<span style=color:#75715e>-- 第二层 (a/b)/c</span>
</span></span><span style=display:flex><span>    z <span style=color:#f92672>=</span> fmap&#39; (<span style=color:#a6e22e>\</span>v <span style=color:#f92672>-&gt;</span> safeDiv v d) y	<span style=color:#75715e>-- 第三层 (a/b/c)/d</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    fmap&#39; (<span style=color:#a6e22e>\</span>v <span style=color:#f92672>-&gt;</span> safeDiv v e) z		<span style=color:#75715e>-- 第四层 (a/b/c/d)/e</span>
</span></span></code></pre></div><p>抛开性能不谈（雾），这种写法看起来已经舒服很多了，但是感觉还是“存在进步空间”的样子。也的确，haskell 给我们提供了一个 <code>>>=</code> 运算符，可以让我们来实现 <code>fmap</code>，并且再次优化上面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- 这是一个中缀运算符，这个例子中 (&gt;&gt;=) m f 等价于 m &gt;&gt;= f；定义与 fmap&#39; 完全一致</span>
</span></span><span style=display:flex><span>(<span style=color:#f92672>&gt;&gt;=</span>) <span style=color:#f92672>::</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span>(<span style=color:#f92672>&gt;&gt;=</span>) m f <span style=color:#f92672>=</span> <span style=color:#66d9ef>case</span> m <span style=color:#66d9ef>of</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>Just</span> x <span style=color:#f92672>-&gt;</span> f x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- the optimzed version</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>safeDiv</span> a b <span style=color:#f92672>&gt;&gt;=</span> (<span style=color:#a6e22e>\</span>v <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>  safeDiv v c <span style=color:#f92672>&gt;&gt;=</span> (<span style=color:#a6e22e>\</span>w <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    safeDiv w d <span style=color:#f92672>&gt;&gt;=</span> (<span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      safeDiv x e)))
</span></span></code></pre></div><p>好像，有点反向优化了？没事，haskell 为这个模式设计了 <code>do</code> 语法糖：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>val</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  x <span style=color:#f92672>&lt;-</span> safeDiv a b
</span></span><span style=display:flex><span>  y <span style=color:#f92672>&lt;-</span> safeDiv x c
</span></span><span style=display:flex><span>  z <span style=color:#f92672>&lt;-</span> safeDiv y d
</span></span><span style=display:flex><span>  safeDiv z e
</span></span></code></pre></div><p>简洁，好看，elegant！这就是“所谓的” monad 了！当然，因为标准库里<a href=https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Maybe.html>已经提供</a>了 <code>instance Monad Maybe</code> 了，所以最后的代码中，我们不需要再定义任何其他函数了，只需要保留 <code>safeDiv</code> 就可以了。当然我们也能自行实现各种各样的 functor，有点像是 OOP 的接口一样（笑）。</p><h2 id=functor-and-monad>Functor and Monad</h2><p>上面的例子中，我们的 <code>fmap'</code> 是自己定义的，而官方针对 <a href=https://hackage.haskell.org/package/base-4.17.0.0/docs/src/GHC.Base.html><code>Maybe</code> 实现的 <code>fmap</code></a> 是不太一样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- | @since 2.01</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span>  <span style=color:#66d9ef>Functor</span> <span style=color:#66d9ef>Maybe</span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    fmap <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>Nothing</span>       <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>    fmap f (<span style=color:#66d9ef>Just</span> a)      <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> (f a)	<span style=color:#75715e>-- notice here!</span>
</span></span></code></pre></div><p>我们的例子中模式匹配项是 <code>Just x -> f x</code>，但是官方的却是 <code>Just a -> Just (f a)</code>，后者其实才是标准格式；<code>safeDiv</code> 这个例子不同是因为我们完全是根据函数类型来“特化”的一个：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- safeDiv version of fmap</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmap</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- haskell fmap, f is functor, eq to `Maybe`</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmap</span> <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> f a <span style=color:#f92672>-&gt;</span> f b
</span></span></code></pre></div><p>可以看到差异在第一个参数类型上。这里提这个区别是因为这里要开始区分 functor 和 monad 了。前文的例子中可能大家会觉得 monad 跟 functor 是一回事，实际上是存在差异的。Haskell 定义了 <a href=https://wiki.haskell.org/Functor-Applicative-Monad_Proposal>Functor-Applicative-Monad</a> 结构，简而言之就是 applicative 必定是 functor，monad 必定是 applicative，三者有继承关系，所以 functor 其实是性质是比较弱的。</p><p>这部分主要会根据哔站<a href=https://www.bilibili.com/video/BV1qh411q7cS>鹤翔万里的视频</a>进行一定的细致阐述，也会对前文刘月半大神的文章进行再补充。先从 functor 开始吧，它的作用看上面函数定义就能略知一二了，给定一个一般的函数，让它去处理“装箱”后的类型，并且返回一个同样被装箱了的类型，看 haskell 的 <code>Maybe</code> 实现就知道了，这里贴出来视频的几个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- instance Functor Maybe</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmap</span> (<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>) (<span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmap</span> (<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- instance Functor []</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmap</span> (<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>) [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>]
</span></span></code></pre></div><p>当然 functor 根据定义，它的局限性就在于只能处理值，对于函数，它只会返回一个装箱后的函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>fmap</span> (<span style=color:#f92672>+</span>) (<span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> (<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><p>并且我们无法继续往下进行了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>fmap</span> (<span style=color:#66d9ef>Just</span> (<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>)) (<span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>🤯</span>
</span></span></code></pre></div><p>这时就需要引入 applicative 来处理了，直接看官方定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- | @since 2.01</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Applicative</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    pure <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Just</span> f  <span style=color:#f92672>&lt;*&gt;</span> m       <span style=color:#f92672>=</span> fmap f m
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>&lt;*&gt;</span> _m      <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    liftA2 f (<span style=color:#66d9ef>Just</span> x) (<span style=color:#66d9ef>Just</span> y) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> (f x y)
</span></span><span style=display:flex><span>    liftA2 <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Just</span> _m1 <span style=color:#f92672>*&gt;</span> m2      <span style=color:#f92672>=</span> m2
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Nothing</span>  <span style=color:#f92672>*&gt;</span> _m2     <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span></code></pre></div><p>主要关注 <code>&lt;*></code> 这个函数（读作 apply），可以看到 applicative 将 <code>Just (+3)</code> 里面的 <code>(+3)</code> 函数给取出来了，然后通过 <code>fmap</code> 应用函数，这样得到的结果依然是个 <code>Maybe</code> 类型，it just works。</p><p>同样，贴上视频中的几个例子当作 memo：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- instance Applicative Maybe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Just</span> (<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- instance Applicative []</span>
</span></span><span style=display:flex><span>[(<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>), (<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>)] <span style=color:#f92672>&lt;*&gt;</span> [<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>]
</span></span></code></pre></div><p>如果我们把前文例子中 <code>safeDiv</code> 里的 <code>fmap'</code> 删去，那么下面这个函数就会开始出类型错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- without customized fmap function</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> safeDiv a b			<span style=color:#75715e>-- 第一层 a/b</span>
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> fmap (<span style=color:#a6e22e>\</span>v <span style=color:#f92672>-&gt;</span> safeDiv v c) x	<span style=color:#75715e>-- 第二层 (a/b)/c</span>
</span></span><span style=display:flex><span>    z <span style=color:#f92672>=</span> fmap (<span style=color:#a6e22e>\</span>v <span style=color:#f92672>-&gt;</span> safeDiv v d) y	<span style=color:#75715e>-- 第三层 (a/b/c)/d</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    fmap (<span style=color:#a6e22e>\</span>v <span style=color:#f92672>-&gt;</span> safeDiv v e) z		<span style=color:#75715e>-- 第四层 (a/b/c/d)/e</span>
</span></span></code></pre></div><p>原因前文说了，<code>fmap</code> 其实返回的是 <code>Just (f a)</code>，也就是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>fmap</span> (<span style=color:#a6e22e>\</span>v <span style=color:#f92672>-&gt;</span> safeDiv v <span style=color:#ae81ff>1</span>) (<span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> (<span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p>这就有点难受了，不是我们预期想要的 <code>Just 10</code>。这种情况下就需要使用 monad 了，也就是上面定义中 <code>>>=</code>（读作 bind）来进行处理了，也是直接看官方代码吧：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- | @since 2.01</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span>  <span style=color:#66d9ef>Monad</span> <span style=color:#66d9ef>Maybe</span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>Just</span> x) <span style=color:#f92672>&gt;&gt;=</span> k      <span style=color:#f92672>=</span> k x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Nothing</span>  <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#66d9ef>_</span>      <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#f92672>&gt;&gt;</span>) <span style=color:#f92672>=</span> (<span style=color:#f92672>*&gt;</span>)
</span></span></code></pre></div><p>对比官方 <code>fmap</code> 就能看到，monad 的 instance 中不再是 <code>Just (k x)</code>，而是简介、明了的 <code>k x</code>，neat。这也是跟我们在 <code>safeDiv</code> 中实现的 <code>>>=</code> 版本完全等价，所以它就是一个 monad。</p><p>依然，贴上一些视频中的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Just</span> (x<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>个人理解，无论是 functor、applicative 还是 monad，它们本质上都是为了更好地处理“被装箱的类型”。而 haskell 比较推崇这种盒子模式，很多类型像 <code>Maybe a</code>、<code>IO a</code> 这种，都实现了 monad 的 bind 运算符。</p><p>比如 Haskell 里常用的数组展开，其实也是借助 functor 来完成的，来自<a href=https://zhuanlan.zhihu.com/p/39734882>评论区的 Narc 大神</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- original</span>
</span></span><span style=display:flex><span>[ x <span style=color:#f92672>+</span> y <span style=color:#f92672>|</span> x <span style=color:#f92672>&lt;-</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>3</span>], y <span style=color:#f92672>&lt;-</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>x]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- desuger</span>
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>3</span>] <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>x] <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#a6e22e>\</span>y <span style=color:#f92672>-&gt;</span> return (x <span style=color:#f92672>+</span> y)
</span></span></code></pre></div><p>另外 JavaScript 的 <code>Promise</code> 也是跟 monad 有点“异曲同工”之妙的，毕竟 lazy eval 能看作是异步（。</p><h2 id=myth>Myth</h2><p>我个人依然有一些迷思，可能需要系统地学习下范畴论才能解惑了。</p><ol><li>都说 monad 能隔离副作用，但是我看下，感觉跟闭包差不多？将所有状态装箱到一个闭包中，当然外部无法修改，<a href=https://stackoverflow.com/a/79077>Stack Overflow 上也有讨论</a>，说区别在于“A monad is (roughly) more like a context in which functions can be chained together sequentially, and controls how data is passed from one function to the next.”</li><li>对用法依然不是很清晰，暂时的想法是，monad 就是用来处理“盒子”的，side effect 可以装进盒子中，error handling 也可以装进去，等等；并且 monad 可以“传递”（不同于 closure 只能捕获函数内的，monad 可以捕获整个链式调用上的结果)，加上 <code>return</code> 函数的辅助，容易实现 chain call，并且 chain 上的函数都共享整个 context？</li><li>一个自函子范畴上的幺半群。。嗯，还是不太懂😂</li></ol><p>还有，原知乎帖子里讲述了一个 <code>join</code> 操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> safeDiv a b
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> fmap (safeDiv c) x
</span></span><span style=display:flex><span>    z <span style=color:#f92672>=</span> (fmap <span style=color:#f92672>.</span> fmap) (safeDiv d) y
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span> (fmap <span style=color:#f92672>.</span> fmap <span style=color:#f92672>.</span> fmap) (safeDiv e) z
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>join</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Maybe</span> (<span style=color:#66d9ef>Maybe</span> a) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> a
</span></span><span style=display:flex><span>  join (<span style=color:#66d9ef>Just</span> x) <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>  join <span style=color:#66d9ef>Nothing</span>  <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#f92672>&gt;&gt;=</span>) <span style=color:#f92672>::</span> <span style=color:#66d9ef>Maybe</span> a <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> b) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> b
</span></span><span style=display:flex><span>  (<span style=color:#f92672>&gt;&gt;=</span>) mbx f <span style=color:#f92672>=</span> join (fmap f mbx)
</span></span></code></pre></div><p>这一部分我暂时还不是很懂，答主给的例子中那一串 <code>fmap</code> 我暂时还是没能推导出类型出来（不太熟悉 <code>.</code> 操作符，是 haskell 超高校级的新手了）。To be continued。</p><p>其实自己还是有挺多地方不懂的，不过 haskell 可能暂时不会再学习了，目前对 erlang 更有兴趣一些，学一门语言等于学完了并发范式，不香吗不香吗（其实主要是数学太渣了，看了一小会范畴论就已经开始歇菜了🤧）。</p></main><footer>&copy;2023 &#183;
<a href=https://error.iorw.io>Byte</a> &#183;
<a href=https://github.com/hartlottery target=_blank rel=noopener>M-x</a></footer></body></html>